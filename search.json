[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Klima 2.0",
    "section": "",
    "text": "Copyright Notice\nThis document represents original work by dark_sole ds@darksole.vip. While contributions from others are gratefully acknowledged, all intellectual property rights remain with the author. The models, algorithms, processes, products, methodologies, and concepts described herein are licenced exclusively for commercial use by the Klima Protocol. No other party may implement, copy, modify, or derive works from these materials without explicit written permission from the author.\n© 2025 dark_sole. All rights reserved."
  },
  {
    "objectID": "index.html#sec-prologue",
    "href": "index.html#sec-prologue",
    "title": "Klima 2.0",
    "section": "1 Prologue",
    "text": "1 Prologue\nKlima 2.0 is an autonomous, rules-based coordination protocol designed to support the retirement of carbon credits through continuous and transparent execution terms.\nIt is not a financial product, investment vehicle, or asset management system, but a piece of market infrastructure that enables carbon supply and retirement demand to interact under predefined conditions.\nThe protocol operates through a dual-token architecture that facilitates coordination without discretionary control: kVCM functions as the internal unit of account and pricing reference for protocol-facilitated carbon retirement, while K2 provides signalling inputs related to system capacity. Together, these tokens inform protocol parameters through deterministic smart-contract logic. This architecture enables the protocol to:\n\ndefine execution rates and intake eligibility for carbon credits against transparent, pre-defined rules;\nmake acquired credits available exclusively for irreversible retirement;\ncoordinate liquidity provision and participation incentives required for continuous operation.\n\nParticipant actions such as locking tokens, signalling preferences, or providing liquidity serve inputs into a coordination mechanism that adjusts protocol parameters within predefined bounds. These inputs do not confer ownership rights, redemption rights, or claims on protocol-held carbon, nor do they constitute discretionary management of assets.\nThe protocol consists of three interdependent functional layers:\n\na carbon inventory layer that holds credits solely for the purpose of facilitating retirement;\na coordination layer that aggregates participant signals to inform protocol parameters; and\na liquidity layer that supports access and withdrawal from the system through external markets.\n\nThese layers are designed to operate together as a self-contained system, adjusting to observable supply and retirement demand without reliance on external oracles, manual intervention, or fee-extractive intermediaries.\nKlima 2.0 abstracts complex carbon market interactions into a transparent and auditable execution framework, enabling participants to interact with carbon retirement infrastructure directly, programmatically, and on equal terms.\nAny economic effects arising from protocol activity result from predefined rules and market interaction, rather than from asset ownership, portfolio management, or profit extraction."
  },
  {
    "objectID": "index.html#sec-klima-2.0",
    "href": "index.html#sec-klima-2.0",
    "title": "Klima 2.0",
    "section": "2 Klima 2.0",
    "text": "2 Klima 2.0\nKlimaDAO launched in 2021 on the Polygon blockchain as an early experiment in applying tokenisation and onchain liquidity to voluntary carbon markets. The initial design centred on the KLIMA token and a treasury-based mechanism intended to bootstrap liquidity and participation in a nascent onchain carbon ecosystem.\nThat first iteration played a meaningful role in demonstrating that carbon credits could be represented, transferred, and retired using blockchain infrastructure. It also catalysed the development of a broader ecosystem of tools and services, including integrations with multiple carbon registries, marketplaces and point-of-sale interfaces, APIs for third-party applications, and direct onchain issuance by project developers.\nOver time, it became clear that the original architecture was not well suited to serving large-scale, enterprise carbon buyers or to supporting continuous, rules-based market operation without manual intervention. In particular, treasury-centric designs introduced complexity, opacity, and governance challenges that limited scalability and operational clarity.\nKlima 2.0 is a ground-up redesign informed by these lessons. Rather than relying on treasury management or discretionary allocation, the new protocol is structured as neutral, non-extractive market infrastructure focused exclusively on facilitating carbon retirement through transparent pricing, programmatic settlement, and open participation.\nThe Klima 2.0 protocol replaces treasury-backed mechanisms with a rules-based coordination model that uses protocol-native tokens to parameterise execution rates, intake capacity, and participation incentives. Carbon credits handled by the protocol are acquired solely to fulfil retirement demand and are not held, traded, or managed for financial gain.\nThis shift reflects a deliberate move away from capital-centric designs toward infrastructure that prioritises auditability, predictability, and long-term operational resilience. Klima 2.0 is intended to function as a shared execution layer for carbon markets, enabling suppliers, buyers, and integrators to interact under predefined conditions without reliance on discretionary intermediaries.\n\n2.1 Protocol Tokens\nKlima 2.0 operates using two protocol-native tokens, kVCM and K2, which together enable rules-based coordination and participation within the system. These tokens do not confer ownership rights, redemption rights, or claims on protocol-handled carbon, and do not represent investment interests.\nkVCM functions as the internal unit of account and pricing reference for protocol-facilitated carbon retirement, while K2 provides signalling inputs related to system capacity. Both tokens are used exclusively to parameterise protocol behaviour through deterministic smart-contract logic.\nkVCM tokens set core allocation choices, whereas K2 acts as the calibration mechanism for inventory development.\n\n\n2.2 High-Level Architecture\nKlima 2.0 is composed of three interdependent functional layers that together support continuous, non-discretionary operation:\n\nCarbon Inventory Layer:\n\nAccumulates carbon credits by minting kVCM.\nSells carbon certificates by burning kVCM.\nSets carbon execution rates based on the system’s code.\n\nCarbon credits handled by the protocol cannot be withdrawn, transferred, or resold. They may only be retired.\nGovernance Layer:\n\nkVCM holders may time-lock their kVCM for a fixed time period and become eligible to select carbon assets for the inventory.\nThis action creates a kVCM Base Accrual curve, which is distributed to the time-locked holders. This is utilised to derive discount rates and governance weightings.\n\nLiquidity Layer:\n\nkVCM and K2 holders are able to pair their tokens together, or in the case of kVCM with USDC, in order to generate liquidity fees in the standard way.\nStaking the resulting liquidity provider tokens may generate a share of protocol incentives.\nLiquidity locked in the kVCM/K2 liquidity pool participates in general governance alongside time-locked kVCM holders.\n\n\nThese layers operate together as a self-contained system that responds only to its own observable state, without reliance on external oracles or centralised intervention.\n\n\n2.3 Incentives and Participation\nThe protocol issues incentives to participants who provide defined services necessary for system operation.\n\n2.3.1 kVCM Incentives\nkVCM incentives are continuously emitted to:\n\nTime-locked kVCM (‘kVCM Base Accrual’).\nUser-locked K2.\nBoth kVCM and K2 liquidity providers.\n\n\n\n2.3.2 K2 Incentives\nThe supply of K2 is allocated at various rates, depending on overall system balances:\n\nTime-locked kVCM.\nUser-locked K2.\nBoth kVCM and K2 liquidity providers.\n\n\n\n\n2.4 Carbon Inventory\nThe protocol’s carbon inventory layer accumulates and retires carbon. It is driven by parameters determined by its rules-based smart contracts, and user activities.\n\n\n\n\n\n\nFigure 1: Klima 2.0 Carbon Inventory.\n\n\n\nCarbon credits are acquired from suppliers, and consumed by offset buyers. Carbon credits are grouped by pre-defined classifications called carbon classes.\nAggregate token holder allocations collectively set the parameters for the execution rates of each class for, both suppliers and retirees, by defining:\n\nInventory weighting.\nCapacity.\n\nAdditional global parameters are also determined by the aggregate allocations, including the kVCM incentive curve.\nThus the Protocol is driven in response to its own native token balances, acting as rules-based carbon market infrastructure to connect available supply with retirement demand. It is able to do so without using oracles or external inputs, and without discretionary allocation, resale, or optimisation of inventory.\n\n\n2.5 Tokens\nLocking or staking the protocol’s tokens allows participants to signal pricing preferences and capacity parameters within the protocol. However, holding or locking the tokens does not represent risk ownership, profit participation, or exposure to carbon price movements. Participants may receive protocol incentives for performing defined coordination functions, distributed according to transparent, rules-based mechanisms.\nTogether, kVCM and K2 enable the protocol to operate as neutral, non-extractive infrastructure, coordinating participation and execution without discretionary management.\n\n2.5.1 kVCM\nkVCM is the protocol’s primary utility token. Its supply is not capped: it grows when new carbon is supplied to the protocol, and contracts when it is retired.\n\nWhen time-locked:\n\nIt may vote for carbon classes for inventory weighting.\nIt receives kVCM base accrual and K2 incentives.\nIn aggregate, it determines the rate of incentive issuance.\n\nTransactional usage:\n\nMint: when suppliers deliver carbon to the protocol.\nBurn: when credits are retired from the protocol.\n\nWhen staked in liquidity pools it is also eligible for incentives, based on the position’s relative share.\n\n\n\n\n\n\n\nFigure 2: Token utility.\n\n\n\n\n\n2.5.2 K2\nK2 is a fixed-supply token distributed programmatically over time.\n\nWhen user-locked:\n\nIt may vote for carbon classes to reduce the difference between execution terms on carbon intake and retirements.\nIt receives kVCM and K2 incentives.\nIn aggregate, it influences the rates of incentive issuance.\n\nWhen staked in the kVCM/K2 liquidity pool it is also eligible for incentives, based on the position’s relative share.\n\n\n\n2.5.3 Utility Functions\nThe kVCM token has two utility functions which are not independent:\n\n\n\n\n\n\nFigure 3: kVCM utility functions.\n\n\n\n\nTime lock: The kVCM token is locked for a specific period of time which determines a kVCM ‘base accrual’ rate. This cannot be amended.\nPrice allocation: Collective selection of carbon classes by kVCM allocations determines the real-time execution ratio for carbon intake and retirements, in kVCM terms. This selection can be amended and withdrawn at any time to allow modulation of protocol parameters.\n\nThe K2 token also has two utility functions:\n\nUser lock: The K2 token remains locked for at least 24 hours.\nCapacity allocation: Collective selection of carbon classes by K2 allocations determines the rate of issuance or retirement of kVCM for the specified carbon class. More capacity allocations on a given carbon class reduce the impact that new transactions have on the execution ratio created by price allocations.\n\nBoth tokens facilitate the carbon market to function efficiently, with the kVCM token responsible for setting execution ratios, and the K2 token modulating capacity.\n\n\n\n2.6 Token Initialisation\nThere is an initial issuance of tokens at the genesis of Klima 2.0. All future emissions are distributed autonomously via incentives.\n\n\n\n\n\n\n\n\n\n\n\nToken\nSupply\nNotes\n\n\n\n\nkVCM\n20 million\n\nSupply expands and contracts programmatically in response to carbon intake and retirement activity.\nA portion of the initial supply is allocated to existing KLIMA holders.\n\n\n\nK2\n100 million\n\nFixed supply.\nDistributed programatically over time, with a portion allocated to existing KLIMA holders.\n\n\n\n\n\n\nTable 1: Token Summary\n\n\n\nkVCM is issued when carbon credits are supplied to the protocol for the purpose of facilitating future retirement, and permanently removed from circulation when carbon is retired. This mint-and-burn process serves as an internal accounting mechanism and does not represent asset ownership or claims on protocol-held carbon.\n\n\n2.7 Participants\n\nCarbon Suppliers & Retirees\nParticipants may supply or retire eligible, tokenised carbon credits to the protocol at quoted execution rates. Supplied credits are handled solely for retirement and cannot be withdrawn, transferred, resold or otherwise arbitraged.\nCarbon inventory: Real-time execution terms for suppliers are continuously updated based on protocol token balances.\nLiquidity Providers\nParticipants may provide liquidity in supported token pairs to facilitate entry and exit from the system. Liquidity provision supports continuous execution and is incentivised according to predefined protocol rules.\nStaked liquidity: Provides continuous incentives for those contributing liquidity to the system.\nGovernance Users\nParticipants who wish to affect carbon price and capacity may do so by allocating kVCM and K2 tokens.\nTime locks & user locks: Provide continuous incentives for those contributing activities that coordinate the protocol.\n\n\n\n2.8 Protocol Design Principles\n\nInfrastructure, Not Extraction:\nKlima 2.0 is designed as shared market infrastructure rather than an extractive financial product. The protocol does not charge fees, take spreads, or operate profit-taking mechanisms for any sponsor, foundation, or investor. All protocol behaviour is rules-based and applies uniformly to all participants, with no privileged economic positions or revenue capture layers.\nDesign intent: Reduce opaque intermediation and hidden margins common in carbon markets, not replace them with a new rent-seeking intermediary.\nConsumption-only Carbon Access:\nCarbon credits handled by the protocol are not exposed for resale, speculation, or secondary trading. Once accepted by the protocol, credits may only be accessed for irreversible retirement through protocol-defined processes.\nDesign intent: Align the system with carbon’s end use (retirement), rather than treating credits as financial instruments.\nCoordination Through Signalling:\nProtocol tokens do not represent ownership of carbon, claims on protocol-held assets, or entitlement to surplus value. Instead, tokens function as signalling and coordination inputs that influence protocol parameters (such as execution conditions and capacity) within predefined bounds.\nDesign intent: Enable decentralised coordination in a complex and competitive environment.\nAutonomous, Rules-based Operation\nAll protocol behaviour — including pricing logic, intake conditions, retirement execution, and incentive distribution — is governed by deterministic smart contracts. Once deployed, the system operates autonomously and does not rely on discretionary decisions by any individual, committee, or organisation.\nDesign intent: Build a trustless, auditable system, that is not based on subjective, opaque intervention.\nEqual Access and Uniform Treatment\nAll participants interact with the protocol on identical terms. There are no side agreements, preferential execution paths, differentiated rights, or bespoke economic arrangements. Protocol rules apply uniformly to all users, including the protocol’s creators and affiliated entities.\nDesign intent: Ensure credibility, neutrality, and resistance to capture.\nMarket-driven Outcomes, Not Managed returns\nAny economic effects associated with protocol participation arise solely from predefined rules and participant interaction with the system. The protocol does not manage assets on behalf of users, target returns, or seek to optimise outcomes for any class of participant.\nDesign intent: Enable transparent market coordination without positioning the protocol as an asset manager or investment vehicle"
  },
  {
    "objectID": "index.html#sec-core-protocol-layers",
    "href": "index.html#sec-core-protocol-layers",
    "title": "Klima 2.0",
    "section": "3 Core Protocol Layers",
    "text": "3 Core Protocol Layers\nFrom this section we refer to kVCM tokens as A, K2 tokens as G, USDC tokens as Q, carbon credits as C, and carbon offset certificates as C*.\nThree layers enable the Klima Protocol to find equilibrium through continuous dynamic feedback loops and overall system balances (supply, demand, token holder positions). There is no centralised management entity with discretionary powers, or fees that can be turned on.\n\nTime-locking mechanics: A token holders can time-lock their tokens until a set date to define system parameters and to have the ability to select carbon classes for system weighting.\n\nThe collective locks influence the A rewards, as well as the real-time execution price for carbon credit acquisitions or retirements.\n\nCarbon inventory layer: the protocol swaps A for carbon credits C (in) or carbon offset certificates C* (out).\n\nBoth allocations of time-locked A tokens and user-locked G tokens are used in the protocol: allocations of A determine the pricing of carbon, and allocations of G determine capacity.\n\nLiquidity layer: External liquidity pools enable conversion between kVCM and supported settlement assets. Liquidity provision supports system availability and users may receive incentivises through the transparent, rule-based approach.\n\nAG liquidity pool: Native token swap A and G.\nAQ liquidity pool: The asset token A with USDC Q.\n\n\nThe Klima system enables each participant to contribute to various aspects of the model, in the interests of their own utility. This, in conjunction with the autonomous model, enables the protocol to fulfill its mandate of facilitating retirement demand into the carbon markets.\n\n3.1 Time-locking Mechanics\nTime-locking A tokens represents a non-custodial commitment to protocol participation for a fixed duration. Lock durations are standardised at 90 days increments and expire on a rolling schedule. There are always 40 durations, extending out to approximately 10 years.\n\nDiscount curve: Aggregate time-locking determines the shape of the discount curve of the A token with regards to execution prices.\nIncentives: Time-locked A tokens may receive incentives, with a rate determined by the base accrual. The base accrual is calculated daily based on user positions, via the ‘time-weighted incentive curve’.\nLocks: Time-locked tokens and any associated A incentives are released only upon time-lock expiration. Early exit is not possible.\n\nG tokens are not involved in the time-locking mechanics. The discount curve is agnostic to carbon class although only time-locked A token holders can allocate their token to carbon classes for portfolio pricing.\n\n3.1.1 Time-weighted Incentive Curve\nDefining:\n\nS: Total time-locked A tokens expressed as a proportion of the outstanding supply of A.\nS_t: Total A tokens time-locked in bucket t, expressed as a proportion of the outstanding supply of A, where {\\sum S_t = S}, and t is the index of standard durations t \\in \\{1, 2, 3, \\dots, 40\\}.\nE_t: Duration expressed in years.\n\nCalculating curve parameters D and C:\n\nD = \\frac{1}{S} \\sum_{t=1}^{40} S_t \\, E_t\n\\tag{1}\n\nC = \\frac{1}{S} \\sum_{t=1}^{40} S_t \\, E_t^2\n\\tag{2}\nThe shape of the time-weighted incentive curve is produced:\n\n\\gamma_t = \\max \\left( \\frac{E_t}{D} - \\frac{E_t^2}{2 \\, C}, \\, 0 \\right)\n\\tag{3}\nNormalising \\gamma_t to \\hat \\gamma_t:\n\n\\hat \\gamma_t = \\frac{\\gamma_t}{\\sum_{t=1}^{40} \\gamma_t}\n\\tag{4}\nWith the cumulative sum of the normalised values expressed as \\Gamma_t:\n\n\\Gamma_t = \\sum_{i=1}^t \\hat \\gamma_i \\quad \\text{for } t = 1, \\dots, 40\n\\tag{5}\nThe time-weighted incentive curve Z_t is solved:\n\nZ_t = (1 - S) \\, \\frac{\\Gamma_t}{E_t}\n\\tag{6}\nWhereupon, the discount rate B_t that forms the discount curve is derived:\n\nB_t = \\exp(-Z_t \\, E_t)\n\\tag{7}\nThe incentives due on time-locked A tokens are calculated daily and added to the locked principal, hence the daily accrual for each duration is calculated:\n\nY_t = \\exp \\left( \\frac{Z_t}{365} \\right) - 1\n\\tag{8}\nHence, any time-locked A stake S_t will increase by a base accrual \\Delta S_t:\n\n\\Delta S_t = S_t \\, Y_t\n\\tag{9}\nWith the total A tokens created on a daily basis for time-locked inflation as\n\nR = \\sum_{t=1}^{40} \\Delta S_t\n\\tag{10}\n\n\n\nviewof inputS = Inputs.range([1e-4, 1], {\n  label: tex`\\text{Time-Locked } S`,\n  step: 1e-4,\n  value: 0.55,\n});\nviewof inputD = Inputs.range([0.25, 10], {\n  label: tex`\\text{Parameter } D`,\n  step: 0.01,\n  value: 4.69,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction constAreaLinear(range, area, inputSlope, slopeFactor = 0.007) {\n  if (range.length === 1) {\n    return [area];\n  }\n\n  let y1 = 0;\n  let y2 = range.length - 1;\n  let slope = slopeFactor * Math.atanh(inputSlope);\n  let intercept = area / range.length;\n\n  if (Math.abs(slope) &gt; 2 * intercept / (y2 - y1 - 1)) {\n    const yExactShift = Math.sqrt(Math.abs(2 * area / slope));\n    const yRoundShift = Math.max(1, Math.round(yExactShift));\n    if (slope &gt; 0) {\n      y1 = y2 - yRoundShift;\n    } else {\n      y2 = y1 + yRoundShift;\n    }\n    slope = Math.sign(slope) * 2 * area / Math.pow((y2 - y1), 2);\n    intercept = Math.abs(slope) * (y2 - y1 - 1) / 2;\n  }\n\n  const yConstArea = [];\n  for (let i = 0; i &lt; range.length; i++) {\n    const y = i - (y1 + y2) / 2;\n    yConstArea.push(Math.max(0, slope * y + intercept));\n  }\n\n  return yConstArea;\n}\n\n\n\n\n\n\n\nvecE = d3.range(0.25, 10.1, 0.25);\n\nscaleE = d3.scaleLinear(d3.extent(vecE), [-1, 1]);\n\nvecS = constAreaLinear(vecE, 0.55, scaleE(inputD)).map(\n  x =&gt; x * inputS / 0.55,\n);\n\nvecReverseCumsumS = d3.cumsum(vecS.slice().reverse()).reverse();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction dotProduct(v, w) {\n  if (v.length !== w.length) {\n    throw new Error(\"Vectors must have the same length\");\n  }\n  return v.reduce((acc, val, i) =&gt; acc + val * w[i], 0);\n}\n\nfunction weightedArithmeticMean(v, weights) {\n  return dotProduct(v, weights) / d3.sum(weights);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparamD = weightedArithmeticMean(vecE, vecS);\n\n\n\n\n\n\n\nparamC = weightedArithmeticMean(vecE.map(e =&gt; e * e), vecS);\n\n\n\n\n\n\n\nfunction computeGamma(vecE, paramD, paramC) {\n  const twoC = 2 * paramC;\n  return vecE.map(e =&gt; Math.max(0, e/paramD - e*e/twoC));\n}\n\n\n\n\n\n\n\nvecGamma = computeGamma(vecE, paramD, paramC);\n\n\n\n\n\n\n\nfunction normalize(v) {\n  const sum = d3.sum(v);\n  return v.map(val =&gt; val / sum);\n}\n\n\n\n\n\n\n\nvecNormGamma = normalize(vecGamma);\n\n\n\n\n\n\n\nvecCumSumGamma = d3.cumsum(vecNormGamma);\n\n\n\n\n\n\n\nfunction computeZ(paramS, vecCumSumGamma, vecE) {\n  return vecCumSumGamma.map((g, t) =&gt; (1 - paramS) * g / vecE[t]);\n}\n\n\n\n\n\n\n\nvecZ = computeZ(inputS, vecCumSumGamma, vecE);\n\n\n\n\n\n\n\nfunction computeB(vecZ, vecE) {\n  return vecZ.map((z, t) =&gt; Math.exp(-z * vecE[t]));\n}\n\n\n\n\n\n\n\nvecB = computeB(vecZ, vecE);\n\n\n\n\n\n\n\nfunction computeY(vecZ) {\n  return vecZ.map(z =&gt; Math.expm1(z));\n}\n\n\n\n\n\n\n\nvecY = computeY(vecZ);\n\n\n\n\n\n\n\nparamI = dotProduct(vecS, vecY);\n\n\n\n\n\n\n\nyieldData = {\n   const yieldData = [];\n   for (let t = 3; t &lt; vecE.length; t += 4) {\n      yieldData.push({\n         key: \"Stake A\",\n         value: 100 * d3.sum(vecS.slice(t - 3, t + 1)),\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Time-weighted Incentive Curve\",\n         value: 100 * vecZ[t],\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Inflation-adjusted Incentives\",\n         value: 100 * (vecZ[t] - paramI),\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Discount Curve\",\n         value: 100 * vecB[t],\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Cumulative Stake A\",\n         value: 100 * vecReverseCumsumS[t - 3],\n         time: vecE[t],\n      });\n   }\n   return yieldData;\n};\ngetStake = d =&gt; d.key === \"Stake A\" ? d.value : NaN;\ngetYieldTerm = d =&gt; d.key === \"Time-weighted Incentive Curve\" ? d.value : NaN;\ngetRealYield = d =&gt; d.key === \"Inflation-adjusted Incentives\" ? d.value : NaN;\ngetDiscount = d =&gt; d.key === \"Discount Curve\" ? d.value : NaN;\ngetCumStake = d =&gt; d.key === \"Cumulative Stake A\" ? d.value : NaN;\n\nstringS = \"Total Stake = \" + inputS.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 },\n);\nstringI = \"Inflation = \" + paramI.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 },\n);\nstringD = `D = ${paramD.toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n)} years`;\nstringC = `√C = ${Math.sqrt(paramC).toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n)} years`;\n\nyieldParams = [\n  { key: stringD, time: paramD },\n  { key: stringC, time: Math.sqrt(paramC) },\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: d3.schemeCategory10,\n    domain: [\n      \"Stake A\",\n      \"Time-weighted Incentive Curve\",\n      \"Inflation-adjusted Incentives\",\n      stringD,\n      stringC,\n    ],\n  },\n  x: {\n    ticks: d3.range(1, 11),\n    domain: [0.25, 10.45],\n    label: \"Duration E (Years)\",\n  },\n  y: {\n    domain: [\n      0,\n      Math.max(d3.max(yieldData, getStake), d3.max(yieldData, getYieldTerm)),\n    ],\n    grid: true,\n  },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Stake A (%)\" }),\n    Plot.axisY({ anchor: \"right\", label: \"Incentive Rates (%)\" }),\n    Plot.rectY(yieldData, {\n      x1: d =&gt; d.time - 0.45,\n      x2: d =&gt; d.time + 0.45,\n      y: getStake,\n      fill: \"key\",\n    }),\n    Plot.ruleX(yieldParams, {\n      x: \"time\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.lineY(yieldData, { x: \"time\", y: getYieldTerm, stroke: \"key\" }),\n    Plot.dotY(yieldData, { x: \"time\", y: getYieldTerm, fill: \"key\" }),\n    Plot.lineY(yieldData, { x: \"time\", y: getRealYield, stroke: \"key\" }),\n    Plot.dotY(yieldData, { x: \"time\", y: getRealYield, fill: \"key\" }),\n  ],\n});\n\n\n\n\n\n\n\n\n(a) Time-weighted incentives (, ).\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [8, 5, 3, 4].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"Cumulative Stake A\", \"Discount Curve\", stringD, stringC],\n  },\n  x: {\n    ticks: d3.range(1, 11),\n    domain: [0.25, 10.45],\n    label: \"Duration E (Years)\"\n  },\n  y: { domain: [0, 100], grid: true },\n  clip: true,\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Cumulative Stake (%)\" }),\n    Plot.axisY({ anchor: \"right\", label: \"Discount (%)\" }),\n    Plot.rectY(yieldData, {\n      x1: d =&gt; d.time - 0.45,\n      x2: d =&gt; d.time + 0.45,\n      y: getCumStake,\n      fill: \"key\",\n    }),\n    Plot.ruleX(yieldParams, {\n      x: \"time\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.lineY(yieldData, { x: \"time\", y: getDiscount, stroke: \"key\" }),\n    Plot.dotY(yieldData, { x: \"time\", y: getDiscount, fill: \"key\" }),\n  ],\n});\n\n\n\n\n\n\n\n\n(b) Discount rates.\n\n\n\n\n\n\nFigure 4: Example of time-locked incentives.\n\n\n\n\n\n\n\nFor visualising the sensitivity of overall A inflation rates with respect to staking and duration, Figure 5 assumes a single duration over the staking range to provide an approximation of inflation \\Delta S \\approx Z \\, S.\n\n\n\n\nfunction contrastingTextColor(backgroundColor) {\n  if (d3.hsl(backgroundColor).l &lt; 0.5) {\n    return \"white\";\n  } else {\n    return \"black\";\n  }\n}\n\n\n\n\n\n\n\nfunction computeApproxDeltaA(paramS, paramE) {\n  return paramS * (1 - paramS) / paramE;\n}\n\n\n\n\n\n\n\ninflationData = {\n  const inflationData = [];\n  for (let paramS = 0; paramS &lt; 1.01; paramS += 0.1) {\n    for (let paramE = 1; paramE &lt;= 10; paramE++) {\n      inflationData.push({\n        key: \"ΔA\",\n        e: paramE,\n        s: paramS,\n        value: computeApproxDeltaA(paramS, paramE),\n      });\n    }\n  }\n  return inflationData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, scheme: \"Spectral\", type: \"sequential\", label: \"ΔS\" },\n  x: { ticks: d3.range(1, 10.1, 1), domain: [10.5, 0.5], label: \"Duration E (Years)\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Staking S\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(inflationData, {\n      x1: d =&gt; d.e - 0.5,\n      x2: d =&gt; d.e + 0.5,\n      y1: d =&gt; d.s - 0.05,\n      y2: d =&gt; d.s + 0.05,\n      fill: \"value\",\n    }),\n    Plot.text(inflationData, {\n      x: \"e\",\n      y: \"s\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [0, computeApproxDeltaA(0.5, 1)],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 5: A inflation rate from base accrual \\Delta S.\n\n\n\n\n\n3.1.2 Protocol Governance Signals\nProtocol governance signals can be derived from two participation cohorts:\n\nTime-locked A tokens: S_t\nStaked liquidity in the A-G pair AG (see Section 3.3), defined here as A_{Gt}, representing the quantity of A tokens held in the liquidity pool expressed as a proportion of circulating supply.\n\nVoting power is allocated by time and applied to the respective balance of A:\n\nInitial voting weights for time-locked A tokens v_t:\n\nv_t = Z_t \\, S_t\n  \\tag{11}\nInitial voting weights for staked liquidity w_t:\n\nw_t = Z_t \\, A_{Gt}\n  \\tag{12}\nFinal voting weights for time-locked A tokens V_t:\n\nV_t = \\frac{v_t}{\\sum_{j=1}^{40} (v_j + 2 w_j)}\n  \\tag{13}\nFinal voting weights for staked liquidity W_t:\n\nW_t = \\frac{w_t}{\\sum_{j=1}^{40} \\left( \\frac 1 2 v_j + w_j \\right)}\n  \\tag{14}\n\n\n\n\n3.2 Carbon Inventory Mechanics\nThe carbon inventory layer ultimately swaps carbon through a set of smart contracts, driven by carbon supply, demand, and user-inputs. The combined allocations of A and G tokens creates a dynamic real-time execution price curve by carbon class.\n\n\n\n\n\n\nFigure 6: Klima 2.0 carbon inventory mechanics.\n\n\n\n\n3.2.1 Carbon Supply\nUser swaps carbon credits for A tokens.\n\n3.2.1.1 Existing Carbon in the Inventory\nFor carbon pricing, both A tokens and G tokens may be allocated to specific carbon classes {i \\in \\{1, 2, 3, \\dots, n\\}} and these are independent allocations between the two tokens.\n\n\n\n\n\n\nFigure 7: Token staking class structure.\n\n\n\nFor a carbon class quantity to be supplied to the protocol, it must have a strictly positive quantity of A tokens allocated to that carbon class, otherwise there is no price, and the carbon cannot be sold.\nDefining:\n\nC_i: Total tonnes of carbon class i currently held in the inventory.\nA_i: A tokens allocated to carbon class i expressed as a proportion of the outstanding supply of A tokens, where {\\sum A_i = A}.\nG_i: G tokens allocated to carbon class i expressed as a proportion of the outstanding supply of G Tokens.\n\nWhere \\Delta C_i is expressed as the relative increment to its respective pool balance, the amount of A tokens issued to pay for carbon, \\Delta A, expressed as a proportion of current supply, is determined as:\n\n\\ln(1 + \\Delta A) =\n  \\left( A_i - \\frac{A_i^2 \\, (1 - G_i)^2}{2} \\right) \\ln(1 + \\Delta C_i)\n\\tag{15}\nDenoting the expression on the right hand side of Equation 15 as \\mathsf{RHS}:\n\n\\Delta A = \\exp(\\mathsf{RHS}) - 1\n\\tag{16}\nFinally, \\Delta A is applied to the outstanding supply of A to solve for token quantities.\nFigure 8 illustrates the G token’s capacity to maintain the initial execution terms of the A token. The data has been normalised in Figure 9 to \\Delta C_i \\, A_i.\n\n\n\nviewof inputDeltaBarCi = Inputs.range([0.01, 1], {\n  label: tex`\\text{Purchased } \\Delta C_i`,\n  step: 0.01,\n  value: 1,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeDeltaA(Ai, Gi, deltaCi) {\n  return Math.expm1((Ai - (Ai**2 * (1 - Gi)**2 / 2)) * Math.log1p(deltaCi));\n}\n\n\n\n\n\n\n\npricingData = {\n  const pricingData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    pricingData.push({\n      key: \"ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    pricingData.push({\n      key: \"Normalised ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      pricingData.push({\n        key: \"ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaA(paramAi, paramGi, inputDeltaBarCi),\n      });\n      pricingData.push({\n        key: \"Normalised ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaA(paramAi, paramGi, inputDeltaBarCi) /\n                (inputDeltaBarCi * paramAi),\n      });\n    }\n  }\n  return pricingData;\n};\ngetDeltaA = d =&gt; d.key === \"ΔA\" ? d.value : NaN;\ngetNormDeltaA = d =&gt; d.key === \"Normalised ΔA\" ? d.value : NaN;\n\nstringInputDeltaBarCi = inputDeltaBarCi.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `ΔA, where ΔC̄ᵢ = ${stringInputDeltaBarCi}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(pricingData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getDeltaA,\n    }),\n    Plot.text(pricingData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeDeltaA(0.1, 1, inputDeltaBarCi),\n            computeDeltaA(1, 1, inputDeltaBarCi),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 8: A price curves (\\Delta A).\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `Normalised ΔA, where ΔC̄ᵢ = ${stringInputDeltaBarCi}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(pricingData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getNormDeltaA,\n    }),\n    Plot.text(pricingData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getNormDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeDeltaA(1, 0, inputDeltaBarCi) / inputDeltaBarCi,\n            computeDeltaA(1, 1, inputDeltaBarCi) / inputDeltaBarCi,\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 9: Normalised A price curves.\n\n\n\n\n\n\n\nNoting that the sensitivity to G_i increases as A_i increases and the effects become more pronounced as \\Delta C_i increases.\n\n\n3.2.1.2 Zero Carbon Scenario\nThere are circumstances when there is zero carbon held in the portfolio for a particular class, i.e. {C_i = 0}, which invalidates the calculation of \\Delta C_i and a different approach is required.\nTaking \\Delta C_\\emptyset as the tonnes of carbon tokens (implying an existing balance of 1 tonne), adjusted for forward discounting, to be sold for any carbon class that has a strictly positive A allocation A_\\emptyset, together with G allocation G_\\emptyset:\n\n\\Delta A =\n  \\frac{\\Delta C_\\emptyset}{1 + \\Delta C_\\emptyset} \\,\n  \\left( A_\\emptyset - \\frac{A_\\emptyset^2 (1 - G_\\emptyset)^2}{2} \\right)^2\n\\tag{17}\n\n\n\nviewof inputDeltaBarCnull = Inputs.range([1e-1, 1e5], {\n  label: tex`\\text{Purchased } \\Delta C_\\emptyset`,\n  step: 1e-1,\n  value: 1e2,\n  transform: Math.log,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeZeroCarbonDeltaA(Ai, Gi, deltaCnull) {\n  return (deltaCnull / (1 + deltaCnull)) * (Ai - (Ai**2 * (1 - Gi)**2 / 2))**2;\n}\n\nfunction computeTrueDeltaA(Ai, Gi, barCiTonnes, deltaBarCiTonnes) {\n  if (barCiTonnes === 0) {\n    return computeZeroCarbonDeltaA(Ai, Gi, deltaBarCiTonnes);\n  } else {\n    const deltaBarCi = deltaBarCiTonnes / barCiTonnes;\n    return computeDeltaA(Ai, Gi, deltaBarCi);\n  }\n}\n\nfunction numberOfDigits(x) {\n  return x === 0 ? 1 : (1 + Math.floor(Math.log10(x)));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeroCarbonData = {\n  const zeroCarbonData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    zeroCarbonData.push({\n      key: \"ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    zeroCarbonData.push({\n      key: \"Normalised ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      zeroCarbonData.push({\n        key: \"ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeZeroCarbonDeltaA(paramAi, paramGi, inputDeltaBarCnull),\n      });\n      zeroCarbonData.push({\n        key: \"Normalised ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeZeroCarbonDeltaA(paramAi, paramGi, inputDeltaBarCnull) /\n                ((inputDeltaBarCnull / (1 + inputDeltaBarCnull)) * paramAi**2),\n      });\n    }\n  }\n  return zeroCarbonData;\n};\n\nstringDeltaBarCnull = inputDeltaBarCnull.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(1, numberOfDigits(inputDeltaBarCnull)),\n    maximumSignificantDigits: Math.max(1, numberOfDigits(inputDeltaBarCnull)),\n  },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `ΔA, where ΔC̄∅ = ${stringDeltaBarCnull} tCO2eq`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(zeroCarbonData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getDeltaA,\n    }),\n    Plot.text(zeroCarbonData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 4, maximumFractionDigits: 4 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeZeroCarbonDeltaA(0.1, 1, inputDeltaBarCnull),\n            computeZeroCarbonDeltaA(1, 1, inputDeltaBarCnull),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 10: A price curves (\\Delta A) in the zero carbon scenario.\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `Normalised ΔA, where ΔC̄∅ = ${stringDeltaBarCnull} tCO2eq`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(zeroCarbonData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getNormDeltaA,\n    }),\n    Plot.text(zeroCarbonData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getNormDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeZeroCarbonDeltaA(1, 0, inputDeltaBarCnull) /\n                    (inputDeltaBarCnull / (1 + inputDeltaBarCnull)),\n            computeZeroCarbonDeltaA(1, 1, inputDeltaBarCnull) /\n                    (inputDeltaBarCnull / (1 + inputDeltaBarCnull)),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 11: Normalised A price curves in the zero carbon scenario.\n\n\n\n\n\n\n\n\n\n\n3.2.2 Sell Offset Certificates\nUser swaps A tokens for carbon offset certificates.\n\n3.2.2.1 Weighted Carbon Class\nFor retiring carbon that is weighted, that is for which there is a strictly positive A token allocation, an A token holder can extract the carbon class offset certificate of their choice C_i but the available pool is only the liquid carbon balance, namely the element C_{i0}:\n\n\\ln(1 + \\Delta C_i) =\n  \\frac{-\\ln(1 + \\Delta A)}{A_i + \\frac 1 2 A_i^2 \\, (1 - G_i)^2}\n\\tag{18}\nAs before, denoting the expression on the right hand side of Equation 18 as \\mathsf{RHS}:\n\n\\Delta C_i = \\exp(\\mathsf{RHS}) - 1\n\\tag{19}\n\n\n\nviewof inputDeltaA = Inputs.range([0.001, 0.999], {\n  label: tex`\\text{Burnt } \\Delta A`,\n  step: 0.001,\n  value: 0.1,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeDeltaCi(Ai, Gi, deltaA) {\n  return Math.expm1(-Math.log1p(deltaA) / (Ai + (Ai**2 * (1 - Gi)**2 / 2)));\n}\n\n\n\n\n\n\n\nretirementData = {\n  const retirementData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    retirementData.push({\n      key: \"-ΔCᵢ\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      retirementData.push({\n        key: \"-ΔCᵢ\",\n        ai: paramAi,\n        gi: paramGi,\n        value: -computeDeltaCi(paramAi, paramGi, inputDeltaA),\n      });\n    }\n  }\n  return retirementData;\n};\n\nstringInputDeltaA = inputDeltaA.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 1, maximumFractionDigits: 1 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `-ΔCᵢ, where ΔA = ${stringInputDeltaA}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(retirementData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: \"value\",\n    }),\n    Plot.text(retirementData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            -computeDeltaCi(1, 0, inputDeltaA),\n            -computeDeltaCi(0.1, 1, inputDeltaA),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 12: Proportion of carbon retired.\n\n\n\n\n\n\n\nFigure 12 shows the cost of carbon increasing with A_i and decreasing on G_i.\n\n\n3.2.2.2 Unweighted Carbon Class\nAn offset certificate for a carbon class with a zero A allocation cannot be extracted from the portfolio by swapping in A tokens.\n\n\n3.2.2.3 Liquidation: \\Delta A = 1\nIn the event that 100% of A tokens are placed into the burn mechanism for carbon offset certificates, the balances of all carbon held in the portfolio post-trade are distributed to all G token holders.\nFigure 13 below shows the spread captured on a ‘round trip’ by the system where \\varepsilon is the proportion retained:\n\n\n\nviewof inputDeltaCinitial = Inputs.range([0.001, 1], {\n  label: tex`\\text{Initial }\\Delta C`,\n  step: 0.001,\n  value: 0.1,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeSpread(Ai, Gi, deltaCinitial) {\n  const deltaA = computeDeltaA(Ai, Gi, deltaCinitial);\n  const deltaCfinal = -computeDeltaCi(Ai, Gi, deltaA);\n  return (deltaCinitial - deltaCfinal) / deltaCinitial;\n}\n\n\n\n\n\n\n\nliquidationData = {\n  const liquidationData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    liquidationData.push({ key: \"deltaa\", ai: 0, gi: paramGi, value: NaN });\n    liquidationData.push({ key: \"deltac\", ai: 0, gi: paramGi, value: NaN });\n    liquidationData.push({ key: \"spread\", ai: 0, gi: paramGi, value: NaN });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      const deltaA = computeDeltaA(paramAi, paramGi, inputDeltaCinitial)\n      liquidationData.push({\n        key: \"deltaa\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaA(paramAi, paramGi, inputDeltaCinitial) /\n                inputDeltaCinitial,\n      });\n      liquidationData.push({\n        key: \"deltac\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaCi(paramAi, paramGi, deltaA) / inputDeltaCinitial,\n      });\n      liquidationData.push({\n        key: \"spread\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeSpread(paramAi, paramGi, inputDeltaCinitial),\n      });\n    }\n  }\n  return liquidationData;\n};\ngetLiqDeltaA = d =&gt; d.key === \"deltaa\" ? d.value : NaN;\ngetLiqDeltaCi = d =&gt; d.key === \"deltac\" ? d.value : NaN;\ngetLiqSpread = d =&gt; d.key === \"spread\" ? d.value : NaN;\n\nstringInputDeltaCinitial = inputDeltaCinitial.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 1, maximumFractionDigits: 1 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, computeSpread(1, 0, 1)],\n    type: \"sequential\",\n    label: `Carbon Spread ε, where initial ΔC = ${stringInputDeltaCinitial}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(liquidationData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getLiqSpread,\n    }),\n    Plot.text(liquidationData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getLiqSpread(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [0, computeSpread(1, 0, inputDeltaCinitial)],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 13: Carbon ‘spread’.\n\n\n\n\n\n\n\nFigure 14 shows the component ‘spread’ contributions on a carbon sale and purchase round trip of a carbon offset certificate.\n\n\n\nInputs.bind(\n  Inputs.range([0.001, 1], {\n    label: tex`\\text{Initial }\\Delta C`,\n    step: 0.001,\n    value: 0.1,\n  }),\n  viewof inputDeltaCinitial,\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: `Component ΔA, where initial ΔC = ${\n      stringInputDeltaCinitial\n    }`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(liquidationData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getLiqDeltaA,\n    }),\n    Plot.text(liquidationData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getLiqDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(d3.interpolateSpectral(d.value)),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\n(a) Carbon ‘spread’ component ΔA.\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Greys\",\n    domain: [\n      -1,\n      computeDeltaCi(\n        1,\n        0,\n        computeDeltaA(1, 0, inputDeltaCinitial) / inputDeltaCinitial,\n      ),\n    ],\n    label: `Component ΔC, where initial ΔC = ${\n      stringInputDeltaCinitial\n    }`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(liquidationData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getLiqDeltaCi,\n    }),\n    Plot.text(liquidationData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getLiqDeltaCi(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            -1,\n            computeDeltaCi(\n              1,\n              0,\n              computeDeltaA(1, 0, inputDeltaCinitial) / inputDeltaCinitial,\n            ),\n          ],\n          d3.interpolateGreys,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\n(b) Carbon ‘spread’ component ΔC.\n\n\n\n\n\n\nFigure 14: Carbon ‘spread’ components.\n\n\n\n\n\n\n\n\n\n\n\n3.3 Liquidity Markets\nBoth A and G tokens can be used for providing liquidity.\n\n\n\n\n\n\nFigure 15: Token liquidity and pricing structure.\n\n\n\nThere are two core liquidity pools:\n\nAn AAM 50:50 pairing of A and G tokens: pool AG.\nA hard currency USDC denoted as Q paired with A: pool AQ.\n\n\n3.3.1 Liquidity Fees\nThe AQ pool will have its own set of fees in the normal way.1\nThe AG pool has different economics as the assets are highly correlated since they represent the same economy. For this reason, the fees are extremely low.\nBy staking liquidity (liquidity provider tokens) to the standard maturities, both pools may receive a distribution of A tokens determined from the Risk Premium calculation below. This is an additional primary issuance to the Base Accrual already discussed.\n\n\n3.3.2 Risk Premium: Beta Determination\nWe can consider the Time-Locked Market yield as the system’s risk-free rate. In addition to this mechanism, a risky spread is determined that is ultimately paid to the staked liquidity providers of the A and G tokens as compensation for the risk levels assumed.\nAs we have seen, the G token has an impact on risk-pricing of A. As G staking increases, the relationship between the carbon class selected under G_i and the portfolio token A strengthens. We can consider G_i staking as an estimate of residual or idiosyncratic risk in the carbon class and this allows us to calculate a portfolio beta \\beta from the implied betas of each carbon class i.\n\n\\beta = \\sqrt{\\sum_{i=1}^n A_i - A_i \\, (1 - G_i)^2}\n\\tag{20}\nThe portfolio \\beta determines a yield factor for the liquidity pools of A to compensate for the implied risk levels.\nFor intuition, the map in Figure 16 shows the various outputs of the function per carbon class.\n\n\n\n\nfunction computeBeta(vecAi, vecGi) {\n  const beta2 = vecAi.reduce(\n    (acc, Ai, i) =&gt; acc + Ai - Ai * (1 - vecGi[i])**2,\n    0,\n  );\n  return Math.sqrt(beta2);\n}\n\n\n\n\n\n\n\nfunction computeBetai(Ai, Gi) {\n  return Math.sqrt(Ai - Ai * (1 - Gi)**2);\n}\n\n\n\n\n\n\n\nbetaData = {\n  const betaData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    betaData.push({\n      key: \"βᵢ\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      betaData.push({\n        key: \"βᵢ\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeBetai(paramAi, paramGi),\n      });\n    }\n  }\n  return betaData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: \"βᵢ\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(betaData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: \"value\",\n    }),\n    Plot.text(betaData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(d3.interpolateSpectral(d.value)),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 16: Range of \\beta_i.\n\n\n\nThe table and figure below show an example of the effects on \\beta of allocating large G_i values to small A_i values where the shift in G_i results in a lower \\beta (0.27 from 0.55) with no change to total G and A allocations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClass\n1\n2\n3\n4\n\\beta\n\n\n\n\nA_i\n0.50\n0.20\n0.10\n0.05\n\n\n\nInitial G_i\n0.30\n0.10\n0.05\n0.01\n\n\n\nInitial \\beta_i^2\n0.2550\n0.0380\n0.0098\n0.0010\n0.5511\n\n\nNew G_i\n0.01\n0.05\n0.10\n0.30\n\n\n\nNew \\beta_i^2\n0.0100\n0.0195\n0.0190\n0.0255\n0.2719\n\n\n\\Delta G_i\n(0.29)\n(0.05)\n0.05\n0.29\n\n\n\n\\Delta \\beta_i^2\n(0.2451)\n(0.0185)\n0.0092\n0.0245\n\n\n\n\n\n\nTable 2: Effect on \\beta from outsized G allocation.\n\n\n\n\n\n\n\narrayAi = [0.5, 0.2, 0.1, 0.05];\narrayInitialGi = [0.3, 0.1, 0.05, 0.01];\narrayNewGi = arrayInitialGi.toReversed();\nbetaContribData = {\n  const betaContribData = [];\n  for (let i = 0; i &lt; arrayAi.length; i++) {\n    const Ai = arrayAi[i];\n    const initialGi = arrayInitialGi[i];\n    const initialBeta2 = computeBetai(Ai, initialGi)**2;\n    const newGi = arrayNewGi[i];\n    const newBeta2 = computeBetai(Ai, newGi)**2;\n    betaContribData.push({ key: \"Initial Gᵢ\", class: i, value: initialGi });\n    betaContribData.push({ key: \"Initial βᵢ²\", class: i, value: initialBeta2 });\n    betaContribData.push({ key: \"New Gᵢ\", class: i, value: newGi });\n    betaContribData.push({ key: \"New βᵢ²\", class: i, value: newBeta2 });\n  }\n  return betaContribData;\n};\ngetInitialG = d =&gt; d.key === \"Initial Gᵢ\" ? d.value : NaN;\ngetInitialBeta2 = d =&gt; d.key === \"Initial βᵢ²\" ? d.value : NaN;\ngetNewG = d =&gt; d.key === \"New Gᵢ\" ? d.value : NaN;\ngetNewBeta2 = d =&gt; d.key === \"New βᵢ²\" ? d.value : NaN;\n\ndomainG = [0, Math.max(d3.max(arrayInitialGi), d3.max(arrayNewGi))];\nrangeBeta2 = [\n  0,\n  Math.max(\n    d3.max(betaContribData, getInitialBeta2),\n    d3.max(betaContribData, getNewBeta2),\n  ),\n];\nscaleG = d3.scaleLinear(domainG, rangeBeta2);\nmapScaleG = x =&gt; x.map(scaleG);\n\nparamInitialBeta = computeBeta(arrayAi, arrayInitialGi);\nparamNewBeta = computeBeta(arrayAi, arrayNewGi);\n\nstringInitialBeta = \"Initial β = \" + paramInitialBeta.toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 4, maximumFractionDigits: 4 },\n);\nstringNewBeta = \"New β = \" + paramNewBeta.toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 4, maximumFractionDigits: 4 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [\"gray\", \"black\", \"blue\", \"red\"],\n    domain: [\"Initial βᵢ²\", \"New βᵢ²\", \"Initial Gᵢ\", \"New Gᵢ\"],\n  },\n  x: {\n    ticks: d3.range(4),\n    label: \"Aᵢ Over 4 Classes\",\n    tickFormat: d =&gt; arrayAi[d],\n  },\n  y: { domain: rangeBeta2 },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"βᵢ²\" }),\n    Plot.axisY(scaleG.ticks(), { anchor: \"right\", label: \"Gᵢ\", y: scaleG }),\n    Plot.rectY(betaContribData, {\n      x1: d =&gt; d.class - 0.45,\n      x2: d =&gt; d.class,\n      y: getInitialBeta2,\n      fill: \"key\",\n    }),\n    Plot.rectY(betaContribData, {\n      x1: d =&gt; d.class,\n      x2: d =&gt; d.class + 0.45,\n      y: getNewBeta2,\n      fill: \"key\",\n    }),\n    Plot.lineY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getInitialG,\n      stroke: \"key\",\n      strokeDasharray: 4,\n    })),\n    Plot.dotY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getInitialG,\n      fill: \"key\",\n    })),\n    Plot.lineY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getNewG,\n      stroke: \"key\",\n      strokeDasharray: 4,\n    })),\n    Plot.dotY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getNewG,\n      fill: \"key\",\n    })),\n    Plot.text([stringInitialBeta], { x: 0.5, y: 0.23, fill: d =&gt; \"blue\" }),\n    Plot.text([stringNewBeta], { x: 2.5, y: 0.23, fill: d =&gt; \"red\" }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 17: Example of G allocation on \\beta.\n\n\n\nFigure 17 shows \\beta’s sensitivity to G allocation as a function of A allocation; that is to say that a large G_i stake on a small A_i stake has limited effects (notwithstanding other consequential factors).\n\n\n3.3.3 Allocation of Risk Premium\nThe full issuance of A tokens is depicted below including now the Risk Premium for the liquidity pools accordingly.\n\n\n\n\n\n\nFigure 18: A token flow structure.\n\n\n\n\n\n3.3.4 Share of Risk Premium\nThe Risk Premium allocation is shared between user-locked G tokens, AG. and AQ pools, with shares \\lambda_{GG}, \\lambda_G, and \\lambda_Q respectively.\nDefining:\n\nG_G: Total G tokens in the AG pool, expressed as a proportion of the outstanding supply of G.\nA_G: Total A tokens in the AG pool, expressed as a proportion of the outstanding supply of A.\nA_Q: Total A tokens in the AQ pool, expressed as a proportion of the outstanding supply of A.\n\nThe allocation to user-locked G tokens, \\lambda_{GG}:\n\n\\lambda_{GG} = \\frac{1 - A_Q}{1 + \\left( \\frac{\\sum_{i=1}^{n}{G_i}}{G_G} \\right)^2}\n\\tag{21}\n\n\n\n\nfunction computeLambdaGG(AQ, Gi, GG) {\n  return (1 - AQ) / (1 + (Gi / GG)**2);\n}\n\nfunction changeTranslation(dx, dy) {\n  return function () {\n    const svgTransformList = this.transform.baseVal;\n    if (svgTransformList.length &gt; 1) {\n      throw new Error(\"SVGTransformList must only contain one translation\");\n    }\n    const {e, f} = svgTransformList.consolidate().matrix;\n    return `translate(${e + dx},${f + dy})`;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlambdaGGData = {\n  const lambdaGGData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    for (let paramAQ = 0; paramAQ &lt; 1.01; paramAQ += 0.1) {\n      lambdaGGData.push({\n        key: \"λ\",\n        aq: paramAQ,\n        gi: paramGi,\n        value: computeLambdaGG(paramAQ, paramGi, 1 - paramGi),\n      });\n    }\n  }\n  return lambdaGGData;\n};\n\n\n\n\n\n\n\nplotLambdaGG = {\n  const plotLambdaGG = Plot.plot({\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"λ\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"A  \" },\n    y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n    marks: [\n      Plot.frame(),\n      Plot.rect(lambdaGGData, {\n        x1: d =&gt; d.aq - 0.05,\n        x2: d =&gt; d.aq + 0.05,\n        y1: d =&gt; d.gi - 0.05,\n        y2: d =&gt; d.gi + 0.05,\n        fill: \"value\",\n      }),\n      Plot.text(lambdaGGData, {\n        x: \"aq\",\n        y: \"gi\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotLambdaGG)\n    .select(\"g[aria-label='x-axis label']\")\n    .select(\"text\")\n      .clone(false)\n      .attr(\"transform\", changeTranslation(-12, 1.5))\n      .attr(\"font-size\", \"0.6em\")\n      .attr(\"font-weight\", \"600\")\n      .text(\"Q\");\n\n  return plotLambdaGG;\n};\n\n\n\n\n\n\n\n\nFigure 19: G stake allocation (assuming G_G = 1 - G_i).\n\n\n\nNoting the relationship between G and \\beta, and particularly if G = 0, \\beta = 0.\nThe residual share, 1 - \\lambda_{GG}, is split between the liquidity pools:\n\n\\lambda_G = (1 - \\lambda_{GG}) \\frac{2 A_G}{2 A_G + A_Q \\sqrt 2}\n\\tag{22}\nFor completeness:\n\n\\lambda_Q = 1 - \\lambda_{GG} - \\lambda_G\n\\tag{23}\n\n\n\n\nfunction computeLambdaG(AQ, AG) {\n  return 2 * AG / (2 * AG + AQ * Math.sqrt(2));\n}\n\n\n\n\n\n\n\nfunction computeLambdaQ(AQ, AG) {\n  return 1 - computeLambdaG(AQ, AG);\n}\n\n\n\n\n\n\n\nlambdaGQData = {\n  const lambdaGQData = [];\n  for (let paramAG = 0; paramAG &lt; 1.01; paramAG += 0.1) {\n    for (let paramAQ = 0; paramAQ &lt; 1.01; paramAQ += 0.1) {\n      if (paramAG + paramAQ &lt; 1.01) {\n        lambdaGQData.push({\n          key: \"Relative 𝗔𝗚 Liquidity Pool Share\",\n          aq: paramAQ,\n          ag: paramAG,\n          value: computeLambdaG(paramAQ, paramAG),\n        });\n        lambdaGQData.push({\n          key: \"Relative 𝗔𝗤 Liquidity Pool Share\",\n          aq: paramAQ,\n          ag: paramAG,\n          value: computeLambdaQ(paramAQ, paramAG),\n        });\n      }\n    }\n  }\n  return lambdaGQData;\n};\n\n\n\n\n\n\n\nplotLambdaGQ = {\n  const plotLambdaGQ = Plot.plot({\n    aspectRatio: 1,\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"λ\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"A  \" },\n    y: {\n      ticks: d3.range(0, 1.01, 0.1),\n      domain: [1.05, -0.05],\n      label: \"A\",\n    },\n    fx: { label: null },\n    className: \"LambdaGQ\",\n    marks: [\n      Plot.frame(),\n      Plot.rect(lambdaGQData, {\n        x1: d =&gt; d.aq - 0.05,\n        x2: d =&gt; d.aq + 0.05,\n        y1: d =&gt; d.ag - 0.05,\n        y2: d =&gt; d.ag + 0.05,\n        fx: \"key\",\n        fill: \"value\",\n      }),\n      Plot.text(lambdaGQData, {\n        x: \"aq\",\n        y: \"ag\",\n        fx: \"key\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotLambdaGQ)\n    .select(\"g[aria-label='x-axis label']\")\n    .select(\"text\")\n    .clone(false)\n      .attr(\"transform\", changeTranslation(-12, 1.5))\n      .attr(\"font-size\", \"0.6em\")\n      .attr(\"font-weight\", \"600\")\n      .text(\"Q\");\n\n  d3.select(plotLambdaGQ)\n    .select(\"g[aria-label='y-axis label']\")\n    .select(\"text\")\n      .attr(\"transform\", changeTranslation(0, 10))\n    .clone(false)\n      .attr(\"transform\", changeTranslation(14, 4.1))\n      .attr(\"font-size\", \"0.6em\")\n      .attr(\"font-weight\", \"600\")\n      .text(\"G\");\n\n  return plotLambdaGQ;\n};\n\n\n\n\n\n\n\n\nFigure 20: Liquidity pool split \\lambda_G, \\lambda_Q.\n\n\n\n\n\n3.3.5 Risk Premium Distribution\nFor \\lambda_{GG}, \\lambda_G, \\lambda_Q we apply \\beta:\n\n\\Lambda_X = \\lambda_X \\, \\beta, \\quad \\text{for } X \\in \\{GG, G, Q\\}\n\\tag{24}\nTaking b as a discount parameter:\n\nb = \\frac{\\sum_1^{40} Z_t \\, S_t \\, B_t}{\\sum_1^{40} Z_t \\, S_t }\n\\tag{25}\nThe total Risk Premium tokens R_\\lambda:\n\nR_\\lambda = b \\, R \\, (\\Lambda_{GG} + \\Lambda_G + \\Lambda_Q)\n\\tag{26}\nThe allocations of R_\\lambda are pro-rata to \\Lambda_{GG}, \\Lambda_G, \\Lambda_Q, and thereafter:\n\nLocked G: \\Lambda_{GG} in proportion to G.\nLocked AG, AQ tokens are allocated a weighting G_t, Q_t depending on their time bucket t:\n\nG_t = \\frac{Z_t \\, L_{Gt} \\, B_t}{\\sum Z_t \\, L_{Gt} \\, B_t}\n  \\tag{27}\n\nQ_t = \\frac{Z_t \\, L_{Qt} \\, B_t}{\\sum Z_t \\, L_{Qt} \\, B_t}\n  \\tag{28}\nWhere L_{Gt}, L_{Qt} are the proportion of all liquidity locked in each time bucket for AG and AQ respectively.\n\nThereafter each time bucket allocation is proportionate to staked liquidity provider token holdings.\n\n\n\n3.4 Interactive Model\nThis additional section is only in the interactive version of the whitepaper. It presents an interactive model of the AAM where each parameter of interest can be adjusted by the reader.\nIn Section 3.4.1, a carbon holder sells carbon to the AAM in exchange for A tokens; from the point of view of the AAM, this represents a carbon purchase. In Section 3.4.2, a holder of A tokens burns them to buy carbon from the AAM; from the point of view of the AAM, this represents a carbon sale.\n\n3.4.1 kVCM Tokens Minted When the AAM Purchases Carbon\nIn this section, the reader controls how many present-value tonnes of carbon class i are purchased by the AAM. The number of A tokens emitted in exchange is calculated in real time. The price of carbon class i is calculated by dividing the number of A tokens emitted by the AAM by the number of present-value tonnes of carbon class i purchased by the AAM.\n\n\n\nfunction piecewiseLogTransform(xTran = 1) {\n  return x =&gt; x &gt; xTran ? Math.log(x) : x - xTran + Math.log(xTran);\n}\n\nfunction piecewiseLogInvert(xTran = 1) {\n  return y =&gt; y &gt; Math.log(xTran) ? Math.exp(y) : y - Math.log10(xTran) + xTran;\n}\n\nfunction setInput(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", { bubbles: true }));\n}\n\nfunction numDigits(x) {\n  return x === 0 ? 1 : (1 + Math.floor(Math.log10(x)));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndefaultAValue = 2e6;\ndefaultASupply = 2e7;\ndefaultPresentTonnes = 1e7;\ndefaultDeltaTonnes = 1e2;\ndefaultAi = 0.5;\ndefaultGi = 0.5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.button(\n  [[\"Reset\", () =&gt; {\n    setInput(viewof inputAValue, defaultAValue);\n    setInput(viewof inputASupply, defaultASupply);\n    setInput(viewof inputPresentTonnes, defaultPresentTonnes);\n    setInput(viewof inputDeltaTonnes, defaultDeltaTonnes);\n    setInput(viewof inputAi, defaultAi);\n    setInput(viewof inputGi, defaultGi);\n  }]],\n);\n\n\n\n\n\n\n\nviewof inputAValue = Inputs.range([1e5, 1e9], {\n  label: tex`\\text{Market cap. of \\textbf{A}}`,\n  step: 1,\n  value: defaultAValue,\n  transform: Math.log,\n});\nviewof inputASupply = Inputs.range([1e6, 1e10], {\n  label: tex`\\text{Supply of \\textbf{A}}`,\n  step: 1,\n  value: defaultASupply,\n  transform: Math.log,\n});\nviewof inputPresentTonnes = Inputs.range([0, 1e9], {\n  label: tex`\\text{Portfolio } C_i`,\n  step: 1e-3,\n  value: defaultPresentTonnes,\n  transform: piecewiseLogTransform(1e-3),\n  invert: piecewiseLogInvert(1e-3),\n});\nviewof inputDeltaTonnes = Inputs.range([1e-3, 1e7], {\n  label: tex`\\text{Purchased tonnes}`,\n  step: 1e-3,\n  value: defaultDeltaTonnes,\n  transform: Math.log,\n});\nviewof inputAi = Inputs.range([0, 1], {\n  label: tex`\\text{Allocation } A_i`,\n  step: 1e-6,\n  value: defaultAi,\n  transform: piecewiseLogTransform(1e-6),\n  invert: piecewiseLogInvert(1e-6),\n});\nviewof inputGi = Inputs.range([0, 1], {\n  label: tex`\\text{Allocation } G_i`,\n  step: 1e-6,\n  value: defaultGi,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparamDeltaA = computeTrueDeltaA(\n  inputAi,\n  inputGi,\n  inputPresentTonnes,\n  inputDeltaTonnes,\n);\nparamDeltaTonnes = paramDeltaA === 0 ? 0 : inputDeltaTonnes;\nparamAEmitted = paramDeltaA * inputASupply;\nparamAPrice = inputAValue / inputASupply;\nparamBarCiPrice = inputAValue * paramDeltaA / inputDeltaTonnes;\n\nstringASupply = inputASupply.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 2 - numDigits(paramAEmitted)),\n    maximumFractionDigits: Math.max(0, 2 - numDigits(paramAEmitted)),\n  },\n) + \" kVCM\";\nstringPresentTonnes = inputPresentTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 3 - numDigits(paramDeltaTonnes)),\n    maximumFractionDigits: Math.max(0, 3 - numDigits(paramDeltaTonnes)),\n  },\n) + \" tCO2eq\";\nstringAEmitted = \"+\" + paramAEmitted.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, numDigits(paramAEmitted)),\n    maximumSignificantDigits: Math.max(2, numDigits(paramAEmitted)),\n  },\n) + \" kVCM\";\nstringDeltaTonnes = \"+\" + paramDeltaTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(3, numDigits(paramDeltaTonnes)),\n    maximumSignificantDigits: Math.max(3, numDigits(paramDeltaTonnes)),\n  },\n) + \" tCO2eq\";\nstringAPrice = \"$\" + paramAPrice.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice)),\n  },\n);\nstringBarCiPrice = \"$\" + paramBarCiPrice.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramBarCiPrice)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramBarCiPrice)),\n  },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSupply of A Tokens\nPortfolio Carbon\n\n\n\n\nTotal\n\n\n\n\nVariation\n\n\n\n\nUnit Price\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 Carbon Sold by the AAM When it Burns kVCM Tokens\nIn this section, the reader controls how many A tokens are burnt by the AAM. The number of liquid tonnes of carbon class i sold by the AAM in exchange is calculated in real time. The price of carbon is calculated by dividing the number of A tokens burnt by the AAM by the number of liquid tonnes of carbon class i sold by the AAM.\n\n\n\ndefaultLiquidTonnes = 1e7;\ndefaultABurnt = 1e2;\ndefaultGnull = 0.5;\ndefaultA = 0.5;\ndefaultS = 0.5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.button(\n  [[\"Reset\", () =&gt; {\n    setInput(viewof inputAValue_, defaultAValue);\n    setInput(viewof inputASupply_, defaultASupply);\n    setInput(viewof inputLiquidTonnes, defaultLiquidTonnes);\n    setInput(viewof inputABurnt, defaultABurnt);\n    setInput(viewof inputAi, defaultAi);\n    setInput(viewof inputGi, defaultGi);\n  }]],\n);\n\n\n\n\n\n\n\nviewof inputAValue_ = Inputs.range([1e5, 1e9], {\n  label: tex`\\text{Market cap. of \\textbf{A}}`,\n  step: 1,\n  value: defaultAValue,\n  transform: Math.log,\n});\nviewof inputASupply_ = Inputs.range([1e6, 1e10], {\n  label: tex`\\text{Supply of \\textbf{A}}`,\n  step: 1,\n  value: defaultASupply,\n  transform: Math.log,\n});\nviewof inputLiquidTonnes = Inputs.range([1e-3, 1e9], {\n  label: tex`\\text{Portfolio } C_{i0}`,\n  step: 1e-3,\n  value: defaultLiquidTonnes,\n  transform: Math.log,\n});\nviewof inputABurnt = Inputs.range([1e-1, 1e6], {\n  label: tex`\\text{\\textbf{A} tokens burnt}`,\n  step: 1e-1,\n  value: defaultABurnt,\n  transform: Math.log,\n});\nInputs.bind(\n  Inputs.range([0, 1], {\n    label: tex`\\text{Allocation } A_i`,\n    step: 1e-6,\n    value: defaultAi,\n    transform: piecewiseLogTransform(1e-6),\n    invert: piecewiseLogInvert(1e-6),\n  }),\n  viewof inputAi,\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.bind(\n  Inputs.range([0, 1], {\n    label: tex`\\text{Allocation } G_i`,\n    step: 1e-6,\n    value: defaultGi,\n  }),\n  viewof inputGi,\n);\n\n\n\n\n\n\n\n\n\nparamABurnt = inputAi === 0 ? 0 : inputABurnt\nparamDeltaA_ = paramABurnt / inputASupply_;\nparamDeltaCi = inputAi === 0 ? -0 : computeDeltaCi(\n  inputAi,\n  inputGi,\n  paramDeltaA_,\n);\nparamDeltaCiTonnes = -paramDeltaCi * inputLiquidTonnes;\nparamAPrice_ = inputAValue_ / inputASupply_;\nparamCiPrice = inputAi === 0 ? 0 : inputAValue_ * paramDeltaA_ / paramDeltaCiTonnes;\n\nstringASupply_ = inputASupply_.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 2 - numDigits(paramABurnt)),\n    maximumFractionDigits: Math.max(0, 2 - numDigits(paramABurnt)),\n  },\n) + \" kVCM\";\nstringLiquidTonnes = inputLiquidTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 2 - numDigits(paramDeltaCiTonnes)),\n    maximumFractionDigits: Math.max(0, 2 - numDigits(paramDeltaCiTonnes)),\n  },\n) + \" tCO2eq\";\nstringABurnt = \"−\" + paramABurnt.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, numDigits(paramABurnt)),\n    maximumSignificantDigits: Math.max(2, numDigits(paramABurnt)),\n  },\n) + \" kVCM\";\nstringDeltaCiTonnes = \"−\" + paramDeltaCiTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, numDigits(paramDeltaCiTonnes)),\n    maximumSignificantDigits: Math.max(2, numDigits(paramDeltaCiTonnes)),\n  },\n) + \" tCO2eq\";\nstringAPrice_ = \"$\" + paramAPrice_.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice_)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice_)),\n  },\n);\nstringCiPrice = \"$\" + paramCiPrice.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramCiPrice)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramCiPrice)),\n  },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSupply of A Tokens\nPortfolio Carbon\n\n\n\n\nTotal\n\n\n\n\nVariation\n\n\n\n\nUnit Price"
  },
  {
    "objectID": "index.html#sec-klima-2.0-token-distribution",
    "href": "index.html#sec-klima-2.0-token-distribution",
    "title": "Klima 2.0",
    "section": "4 Klima 2.0 Token Distribution",
    "text": "4 Klima 2.0 Token Distribution\n\n4.1 Planned Allocations\n\n\n\n\n\n\nCohort\nProportion\nQuantity (m)\n\n\n\n\nKlima Holders\n87.5%\n17.5\n\n\nDAO/Treasury\n10.0%\n2.0\n\n\n01X\n2.5%\n0.5\n\n\nTotal\n100.0%\n20.0\n\n\n\n\n\nTable 3: kVCM token.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort\nProportion\nQuantity (m)\nLiquidity\n\n\n\n\nKlima Holders\n40.0%\n40.0\nLogistic Vesting 48 months\n\n\nEcosystem Grant\n5.0%\n5.0\nLogistic Vesting 48 months\n\n\nProgrammatic Incentives\n40.0%\n40.0\nIncentive Curve\n\n\npKlima Holders\n3.0%\n3.0\nLogistic Vesting 48 months\n\n\nDAO/Treasury\n4.5%\n4.5\n24 month locked LP of AG\n\n\n01X\n2.5%\n2.5\n24 month locked LP of AG\n\n\nProduct Design and Development\n5.0%\n5.0\nLogistic Vesting 48 months\n\n\nTotal\n100.0%\n100.0\n\n\n\n\n\n\nTable 4: K2 token.\n\n\n\n\n\n\n\nallocInitGData = {\n  const allocInitGData = [];\n  for (let i = 0; i &lt; 100.01; i += 0.25) {\n    if (i &lt; 2.51) {\n      allocInitGData.push({ key: \"01X\", value: i });\n    }\n    if (2.49 &lt; i && i &lt; 5.51) {\n      allocInitGData.push({ key: \"pKlima Holders\", value: i });\n    }\n    if (5.49 &lt; i && i &lt; 10.01) {\n      allocInitGData.push({ key: \"DAO/Treasury\", value: i });\n    }\n    if (9.99 &lt; i && i &lt; 15.01) {\n      allocInitGData.push({ key: \"Ecosystem Grant\", value: i });\n    }\n    if (14.99 &lt; i && i &lt; 20.01) {\n      allocInitGData.push({ key: \"Product Design\", value: i });\n    }\n    if (19.99 &lt; i && i &lt; 60.01) {\n      allocInitGData.push({ key: \"Klima Holders\", value: i });\n    }\n    if (59.99 &lt; i) {\n      allocInitGData.push({ key: \"Incentives\", value: i });\n    }\n  }\n  return allocInitGData;\n};\nlongitudeScale = d3.scaleLinear([180, -180]);\ngetCenter = d =&gt;\n        [1.25, 4, 7.75, 12.5, 17.5, 40, 80].includes(d.value) ? d.value : NaN;\n\ncohortsDomain = [\n  \"Incentives\",\n  \"Klima Holders\",\n  \"Product Design\",\n  \"Ecosystem Grant\",\n  \"DAO/Treasury\",\n  \"pKlima Holders\",\n  \"01X\",\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  projection: { type: \"azimuthal-equidistant\", rotate: [0, -90], scale: 2 },\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  marks: [\n    Plot.area(allocInitGData, {\n      x1: ({ value }) =&gt; longitudeScale(value / 100),\n      y1: -20,\n      x2: ({ value }) =&gt; longitudeScale(value / 100),\n      y2: -70,\n      fill: \"key\",\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\nFigure 21: K2 token allocations.\n\n\n\n\n\n4.2 Programmatic Incentive Curve\nThe incentive issuance is built on a logistic function, \\operatorname{P}, to generate total proportion of supply in issue. It is calibrated from the initial issuance at TGE P_0 and the inflection point time T where 50% of G token incentives have been released.\nSetting x_0 from the initial supply parameter:\n\nx_0 = \\ln\\left( \\frac{P_0}{1 - P_0} \\right)\n\\tag{29}\nWith x_t at time point t \\in (0, \\infty):\n\nx_t = x_0 \\, \\left( 1 - \\frac t T \\right)\n\\tag{30}\nGiving supply function \\operatorname{P}(t) as:\n\n\\operatorname{P}(t) = \\frac{\\exp(x_t)}{\\exp(x_t) + 1}\n\\tag{31}\nP_0 set at  and T at  months:\n\n\n\nviewof inputP0 = Inputs.range([0.01, 0.5], {\n  label: tex`\\text{Initial issuance } P_0`,\n  step: 0.01,\n  value: 0.07,\n});\nviewof inputT = Inputs.range([2, 60], {\n  label: tex`T \\text{ (months)}`,\n  step: 1,\n  value: 24,\n});\n\nstringInputP0 = inputP0.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n);\nstringInputT = inputT.toLocaleString(\"en-GB\", { maximumFractionDigits: 0 });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeP(t, P0, T) {\n  const x0 = Math.log(P0 / (1 - P0));\n  const xt = x0 * (1 - t / T);\n  const exp = Math.exp(xt);\n  return exp / (exp + 1);\n}\n\nfunction computeDerivP(t, P0, T) {\n  const x0 = Math.log(P0 / (1 - P0));\n  const xt = x0 * (1 - t / T);\n  const exp = Math.exp(xt);\n  const P = exp / (1 + exp);\n  return -(x0 / T) * P * (1 - P);\n}\n\nfunction getVesting(vecVesting, t, tStart, tEnd) {\n  if (t &lt; tStart)\n    return 0;\n  else if (t &lt; tEnd) {\n    return vecVesting[t - tStart];\n  } else {\n    return vecVesting[tEnd - tStart - 1];\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntVestStart = 3;\ntVestEnd = 2 * inputT;\ntVesting = d3.range(tVestStart, tVestEnd);\nvecVestingDeriv = normalize(tVesting.map(t =&gt;\n  computeDerivP(t, inputP0, inputT)\n));\nvecVesting = d3.cumsum(vecVestingDeriv);\n\nsupplyDataAll = {\n  let paramVestingPrevious = 0;\n  const vecSupplyIncentives = [];\n  const vecSupplyCirculating = [];\n  const supplyData = [];\n  for (let t = 0; t &lt;= 72; t++) {\n    const paramP = computeP(t, inputP0, inputT);\n    const paramDerivP = computeDerivP(t, inputP0, inputT);\n    const paramVesting = getVesting(vecVesting, t, tVestStart, tVestEnd);\n    const paramVestingDiff = paramVesting - paramVestingPrevious;\n    paramVestingPrevious = paramVesting;\n\n    const supply01X = 2.5;\n    const supplyPKlima = 3 * paramVesting;\n    const supplyTreasury = 4.5;\n    const supplyGrant = 5 * paramVesting;\n    const supplyProduct = 5 * paramVesting;\n    const supplyKlima = 40 * paramVesting;\n    const supplyIncentives = 40 * paramP;\n    vecSupplyIncentives.push(supplyIncentives);\n\n    const supply01XStacked = supply01X;\n    const supplyPKlimaStacked = supplyPKlima + supply01XStacked;\n    const supplyTreasuryStacked = supplyTreasury + supplyPKlimaStacked;\n    const supplyGrantStacked = supplyGrant + supplyTreasuryStacked;\n    const supplyProductStacked = supplyProduct + supplyGrantStacked;\n    const supplyKlimaStacked = supplyKlima + supplyProductStacked;\n    const supplyIncentivesStacked = supplyIncentives + supplyKlimaStacked;\n    const supplyCirculating = supplyIncentivesStacked / 100;\n    vecSupplyCirculating.push(supplyIncentivesStacked);\n\n    if (t &lt;= 60) {\n      const diffIncentives = 40 * (t === 0 ? inputP0 : paramDerivP);\n      const diffKlima = 40 * paramVestingDiff;\n      const diffProduct = 5 * paramVestingDiff;\n      const diffGrant = 5 * paramVestingDiff;\n      const diffPKlima = 3 * paramVestingDiff;\n      const diffTreasury = t === 0 ? 4.5: 0;\n      const diff01X = t === 0 ? 2.5 : 0;\n\n      const diffIncentivesStacked = diffIncentives;\n      const diffKlimaStacked = diffKlima + diffIncentivesStacked;\n      const diffProductStacked = diffProduct + diffKlimaStacked;\n      const diffGrantStacked = diffGrant + diffProductStacked;\n      const diffPKlimaStacked = diffPKlima + diffGrantStacked;\n      const diffTreasuryStacked = diffTreasury + diffPKlimaStacked;\n      const diff01XStacked = diff01X + diffTreasuryStacked;\n\n      supplyData.push({\n        key: \"Proportion of Supply\",\n        x: t,\n        y: 100 * paramP,\n      });\n      supplyData.push({\n        key: \"Rate of Change\",\n        x: t,\n        y: 100 * paramDerivP,\n      });\n\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01XStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlimaStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasuryStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrantStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProductStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlimaStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentivesStacked / supplyCirculating,\n      });\n\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01X / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlima / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasury / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrant / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProduct / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlima / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentives / supplyCirculating,\n      });\n\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01XStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlimaStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasuryStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrantStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProductStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlimaStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentivesStacked,\n      });\n\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01X,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasury,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrant,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProduct,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentives,\n      });\n\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: diffIncentives,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: diffKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: diffProduct,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: diffGrant,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: diffPKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: diffTreasury,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: diff01X,\n      });\n    }\n  }\n\n  const vecNextYearIncentives = vecSupplyIncentives.map((val, t) =&gt;\n    vecSupplyIncentives[t + 12] - val);\n  const vecAPY = vecSupplyCirculating.map((val, t) =&gt;\n    100 * (vecSupplyCirculating[t + 12] - val) / val);\n  const vecAPR = vecSupplyCirculating.map((val, t) =&gt;\n    100 * (vecSupplyCirculating[t + 12] - vecNextYearIncentives[t] - val) / val);\n\n  for (let t = 0; t &lt;= 60; t++) {\n    supplyData.push({ key: \"APY\", x: t, y: vecAPY[t] });\n    supplyData.push({ key: \"APR\", x: t, y: vecAPR[t] });\n  }\n  return [\n    vecSupplyIncentives,\n    vecSupplyCirculating,\n    supplyData,\n    vecAPY,\n    vecAPR,\n  ];\n}\nvecSupplyIncentives = supplyDataAll[0];\nvecSupplyCirculating = supplyDataAll[1];\nsupplyData = supplyDataAll[2];\nvecAPY = supplyDataAll[3];\nvecAPR = supplyDataAll[4];\n\ngetLogisticCurve = d =&gt; d.key === \"Proportion of Supply\" ? d.y : NaN;\ngetRateOfChange = d =&gt; d.key === \"Rate of Change\" ? d.y : NaN;\ngetCirculatingStacked = d =&gt;\n        d.key === \"Circulating Supply (Stacked)\" ? d.y : NaN;\ngetCirculatingUnstacked = d =&gt;\n        d.key === \"Circulating Supply (Unstacked)\" ? d.y : NaN;\ngetTotalStacked = d =&gt; d.key === \"Total Supply (Stacked)\" ? d.y : NaN;\ngetTotalUnstacked = d =&gt; d.key === \"Total Supply (Unstacked)\" ? d.y : NaN;\ngetDiffUnstacked = d =&gt;\n        d.key === \"Total Supply Differential (Unstacked)\" ? d.y : NaN;\ngetCohortCirculatingStacked = d =&gt;\n        d.key === \"Circulating Supply (Stacked)\" ? d.cohort : NaN;\ngetCohortCirculatingUnstacked = d =&gt;\n        d.key === \"Circulating Supply (Unstacked)\" ? d.cohort : NaN;\ngetCohortTotalStacked = d =&gt;\n        d.key === \"Total Supply (Stacked)\" ? d.cohort : NaN;\ngetCohortTotalUnstacked = d =&gt;\n        d.key === \"Total Supply (Unstacked)\" ? d.cohort : NaN;\ngetCohortDiffUnstacked = d =&gt;\n        d.key === \"Total Supply Differential (Unstacked)\" ? d.cohort : NaN;\ngetAPY = d =&gt; d.key === \"APY\" ? d.y : NaN;\ngetAPR = d =&gt; d.key === \"APR\" ? d.y : NaN;\n\ndomainRateOfChange = [0, d3.max(supplyData, getRateOfChange)];\nscaleRateOfChange = d3.scaleLinear(domainRateOfChange, [0, 100]);\nmapScaleRateOfChange = x =&gt; x.map(scaleRateOfChange);\n\nstringP0 = \"Initial Issuance P₀ = \" + inputP0.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n);\nstringT = \"Inflection Point Time T = \" + inputT.toLocaleString(\n  \"en-GB\",\n  { maximumFractionDigits: 0 },\n) + \" months\";\n\nsupplyParams = [\n  { key: stringP0, x: 0.5, y: 100 * inputP0 },\n  { key: stringT, x: inputT, y: 50 },\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [5, 7, 0, 2].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"Proportion of Supply\", \"Rate of Change\", stringP0, stringT],\n  },\n  x: {\n    ticks: d3.range(0, 60.1, 12),\n    label: \"‘Life’ Span (Months)\",\n    grid: true,\n  },\n  y: { domain: [0, 100] },\n  insetTop: 16,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Proportion of Supply (%)\" }),\n    Plot.axisY(scaleRateOfChange.ticks(), {\n      anchor: \"right\",\n      tickFormat: scaleRateOfChange.tickFormat(),\n      label: \"Rate of Change (%/Month)\",\n      y: scaleRateOfChange\n    }),\n    Plot.lineY(supplyData, Plot.mapY(mapScaleRateOfChange, {\n      x: \"x\",\n      y: getRateOfChange,\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    })),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getLogisticCurve,\n      stroke: \"key\",\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, Plot.mapY(mapScaleRateOfChange, {\n      x: \"x\",\n      y: getRateOfChange,\n      fill: \"key\",\n      fillOpacity: 0.3,\n    })),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y: getLogisticCurve,\n      fill: \"key\",\n      fillOpacity: 0.3,\n    }),\n    Plot.ruleX(supplyParams, {\n      x: d =&gt; d.key === stringT ? d.x : NaN,\n      y: \"y\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.dotY(supplyParams, {\n      x: \"x\",\n      y: \"y\",\n      r: 5,\n      fill: \"key\",\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\nFigure 22: Incentive Issuance\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { domain: [0, 100], label: \"Circulating Supply (%)\", grid: true },\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getCirculatingStacked,\n      stroke: getCohortCirculatingStacked,\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y: getCirculatingUnstacked,\n      fill: getCohortCirculatingUnstacked,\n      fillOpacity: 0.5,\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\nFigure 23: K2 token circulating supply over time.\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { domain: [0, 100], label: \"Total Supply (%)\", grid: true },\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getTotalStacked,\n      stroke: getCohortTotalStacked,\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y: getTotalUnstacked,\n      fill: getCohortTotalUnstacked,\n      fillOpacity: 0.5,\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n(a) Total supply (stacked).\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { label: \"Total Supply (%)\", grid: true },\n  insetTop: 16,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getTotalUnstacked,\n      stroke: getCohortTotalUnstacked,\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y1: 0,\n      y2: getTotalUnstacked,\n      fill: getCohortTotalUnstacked,\n      fillOpacity: 0.2,\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n(b) Total supply (unstacked).\n\n\n\n\n\n\nFigure 24: K2 token total supply over time.\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { label: \"Rate of Growth (%/Month)\", grid: true },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.rectY(supplyData, {\n      x1: d =&gt; d.x - 0.45,\n      x2: d =&gt; d.x + 0.45,\n      y: getDiffUnstacked,\n      fill: getCohortDiffUnstacked,\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\n(a) Total supply differential (stacked).\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [9, 8].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"APY\", \"APR\"],\n  },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: {\n    domain: [0, Math.max(d3.max(vecAPR), d3.max(vecAPY))],\n    label: \"Annual Percentage (%)\",\n    grid: true,\n  },\n  insetTop: 16,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getAPY,\n      stroke: \"key\",\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y1: 0,\n      y2: getAPY,\n      fill: \"key\",\n      fillOpacity: 0.2,\n    }),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getAPR,\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\n(b) Utility incentive yield.\n\n\n\n\n\n\nFigure 25: K2 token supply risk metrics.\n\n\n\n\n\n\n\n\n\n4.3 Incentive Allocations\n\n\n\n\n\n\nFigure 26: K2 token incentive distribution structure.\n\n\n\nThe relative utilisation measurement factor \\upsilon is calculated as follows.\nDefining initially:\n\nG: Total G tokens staked expressed as a proportion of the circulating supply, G \\in [0, 1].\nL: Total G tokens held in the AG pool expressed as a proportion of circulating supply, L \\in (0, 1].\n\nWhere \\upsilon = 0 if G + L = 0, otherwise:\n\n\\upsilon = \\left( \\frac{2 G L}{G^2 + L^2} \\right)^2\n\\tag{32}\n\n\n\n\nfunction computeUpsilon(G, L) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return (2 * G * L / (G**2 + L**2))**2;\n  }\n}\n\n\n\n\n\n\n\nupsilonData = {\n  const upsilonData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.05) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.05) {\n      if (paramG + paramL &lt; 1.01) {\n        upsilonData.push({\n          key: \"υ\",\n          l: paramL,\n          g: paramG,\n          value: computeUpsilon(paramG, paramL),\n        });\n      }\n    }\n  }\n  return upsilonData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  aspectRatio: 1,\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: \"Relative Utilisation υ\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n  y: {\n    ticks: d3.range(0, 1.01, 0.1),\n    domain: [1.025, -0.025],\n    label: \"Stake G\",\n  },\n  marks: [\n    Plot.frame(),\n    Plot.rect(upsilonData, {\n      x1: d =&gt; d.l - 0.025,\n      x2: d =&gt; d.l + 0.025,\n      y1: d =&gt; d.g - 0.025,\n      y2: d =&gt; d.g + 0.025,\n      fill: \"value\",\n    }),\n    Plot.text(upsilonData, {\n      x: \"l\",\n      y: \"g\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 27: Upsilon \\upsilon range of values.\n\n\n\nThe absolute utilisation parameter \\eta is defined as \\eta = 0 if G + L = 0, otherwise:\n\n\\eta = \\frac{2 G L}{G (1 - G) + L ( 1 - L)}\n\\tag{33}\n\n\n\n\nfunction computeEta(G, L) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return 2 * G * L / (G * (1 - G) + L * (1 - L));\n  }\n}\n\n\n\n\n\n\n\netaData = {\n  const etaData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.05) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.05) {\n      if (paramG + paramL &lt; 1.01) {\n        etaData.push({\n          key: \"η\",\n          l: paramL,\n          g: paramG,\n          value: computeEta(paramG, paramL),\n        });\n      }\n    }\n  }\n  return etaData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  aspectRatio: 1,\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: \"Absolute Utilisation η\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n  y: {\n    ticks: d3.range(0, 1.01, 0.1),\n    domain: [1.025, -0.025],\n    label: \"Stake G\",\n  },\n  marks: [\n    Plot.frame(),\n    Plot.rect(etaData, {\n      x1: d =&gt; d.l - 0.025,\n      x2: d =&gt; d.l + 0.025,\n      y1: d =&gt; d.g - 0.025,\n      y2: d =&gt; d.g + 0.025,\n      fill: \"value\",\n    }),\n    Plot.text(etaData, {\n      x: \"l\",\n      y: \"g\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 28: Eta \\eta range of values.\n\n\n\nIncentives I are allocated as follows:\n\n4.3.1 Treasury\nThe allocation to the Treasury I_T is the imbalance generated from \\upsilon:\n\nI_T = 1 - \\upsilon \\, \\eta\n\\tag{34}\n\n\n4.3.2 Post Treasury\nThe residual post-treasury allocation is shared four ways within 2 buckets:\n\nTime-locked A & user-locked G tokens\nWhere S is the proportion of time-locked A tokens (as defined previously in Section 3.1.1):\n\nTime-locked A, I_S:\n\nI_S = S \\, \\frac{L^2}{G^2 + L^2}\n  \\tag{35}\nUser-locked G, I_G:\n\nI_G = (1 - S) \\, \\frac{L^2}{G^2 + L^2}\n  \\tag{36}\n\nLiquidity\nWith \\lambda_G, \\lambda_Q, \\lambda_{GG} as defined in Section 3.3.4:\n\nAG pool I_{AG}:\n\nI_{AG} = \\frac{\\lambda_G}{1 - \\lambda_{GG}} \\, \\frac{G^2}{G^2 + L^2}\n  \\tag{37}\nAQ pool I_{AQ}:\n\nI_{AQ} = \\frac{\\lambda_Q}{1 - \\lambda_{GG}} \\, \\frac{G^2}{G^2 + L^2}\n  \\tag{38}\n\n\n\n\n\nviewof inputS_ = Inputs.range([0, 1], {\n  label: tex`\\text{Time-Locked } S`,\n  step: 0.01,\n  value: 0.5,\n});\n\nviewof inputWeightAG = Inputs.range([0, 1], {\n  label: tex`\\text{LP split}`,\n  step: 0.01,\n  value: 0.5,\n});\n\nparamWeightAQ = 1 - inputWeightAG;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeTreasury(G, L) {\n  return Math.max(0, 1 - computeUpsilon(G, L) * computeEta(G, L));\n}\n\n\n\n\n\n\n\nfunction computeIBonds(G, L, S) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return S * L**2 / (G**2 + L**2);\n  }\n}\n\nfunction computeIStaking(G, L, S) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return (1 - S) * L**2 / (G**2 + L**2);\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeIPool(G, L, weight) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return weight * G**2 / (G**2 + L**2);\n  }\n}\n\n\n\n\n\n\n\nallocationSQData = {\n  const allocationSQData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.1) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.1) {\n      if (paramG + paramL &lt; 1.01) {\n        allocationSQData.push({\n          key: \"𝗔 Time-locks Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIBonds(paramG, paramL, inputS_),\n        });\n        allocationSQData.push({\n          key: \"𝗚 User-locks Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIStaking(paramG, paramL, inputS_),\n        });\n      }\n    }\n  }\n  return allocationSQData;\n};\n\n\n\n\n\n\n\nplotAllocationSQ = {\n  const plotAllocationSQ = Plot.plot({\n    aspectRatio: 1,\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"Allocation I\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n    y: {\n      ticks: d3.range(0, 1.01, 0.1),\n      domain: [1.05, -0.05],\n      label: \"Stake G\",\n    },\n    fx: { label: null },\n    marks: [\n      Plot.frame(),\n      Plot.rect(allocationSQData, {\n        x1: d =&gt; d.l - 0.05,\n        x2: d =&gt; d.l + 0.05,\n        y1: d =&gt; d.g - 0.05,\n        y2: d =&gt; d.g + 0.05,\n        fx: \"key\",\n        fill: \"value\",\n      }),\n      Plot.text(allocationSQData, {\n        x: \"l\",\n        y: \"g\",\n        fx: \"key\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotAllocationSQ)\n    .select(\"g[aria-label='y-axis label']\")\n    .select(\"text\")\n      .attr(\"transform\", changeTranslation(0, 10));\n\n  return plotAllocationSQ;\n};\n\n\n\n\n\n\n\n\n(a) Time-locked A and user-locked G allocations.\n\n\n\n\n\nallocationPoolData = {\n  const allocationPoolData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.1) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.1) {\n      if (paramG + paramL &lt; 1.01) {\n        allocationPoolData.push({\n          key: \"𝗔𝗚 Pool Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIPool(paramG, paramL, inputWeightAG),\n        });\n        allocationPoolData.push({\n          key: \"𝗔𝗤 Pool Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIPool(paramG, paramL, paramWeightAQ),\n        });\n      }\n    }\n  }\n  return allocationPoolData;\n};\n\n\n\n\n\n\n\nplotAllocationPool = {\n  const plotAllocationPool = Plot.plot({\n    aspectRatio: 1,\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"Allocation I\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n    y: {\n      ticks: d3.range(0, 1.01, 0.1),\n      domain: [1.05, -0.05],\n      label: \"Stake G\",\n    },\n    fx: { label: null },\n    marks: [\n      Plot.frame(),\n      Plot.rect(allocationPoolData, {\n        x1: d =&gt; d.l - 0.05,\n        x2: d =&gt; d.l + 0.05,\n        y1: d =&gt; d.g - 0.05,\n        y2: d =&gt; d.g + 0.05,\n        fx: \"key\",\n        fill: \"value\",\n      }),\n      Plot.text(allocationPoolData, {\n        x: \"l\",\n        y: \"g\",\n        fx: \"key\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotAllocationPool)\n    .select(\"g[aria-label='y-axis label']\")\n    .select(\"text\")\n      .attr(\"transform\", changeTranslation(0, 10));\n\n  return plotAllocationPool;\n};\n\n\n\n\n\n\n\n\n(b) Liquidity pools allocations.\n\n\n\n\n\n\nFigure 29: Share of non-treasury incentives I_S, I_G, I_{AG} and I_{AQ}.\n\n\n\n\n\n\n\n\n\n\n\ntreasuryData = {\n  const treasuryData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.05) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.05) {\n      if (paramG + paramL &lt; 1.01) {\n        treasuryData.push({\n          key: \"I_T\",\n          l: paramL,\n          g: paramG,\n          value: computeTreasury(paramG, paramL),\n        });\n      }\n    }\n  }\n  return treasuryData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  aspectRatio: 1,\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: \"Allocation I\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n  y: {\n    ticks: d3.range(0, 1.01, 0.1),\n    domain: [1.025, -0.025],\n    label: \"Stake G\",\n  },\n  marks: [\n    Plot.frame(),\n    Plot.rect(treasuryData, {\n      x1: d =&gt; d.l - 0.025,\n      x2: d =&gt; d.l + 0.025,\n      y1: d =&gt; d.g - 0.025,\n      y2: d =&gt; d.g + 0.025,\n      fill: \"value\",\n    }),\n    Plot.text(treasuryData, {\n      x: \"l\",\n      y: \"g\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n      ),\n    }),\n  ],\n})\n\n\n\n\n\n\n\n\nFigure 30: Treasury incentives I_T."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Klima 2.0",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote the development of liquidity pool pricing functionality may be applicable.↩︎"
  }
]