[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Klima 2.0",
    "section": "",
    "text": "Copyright Notice\nThis document represents original work by dark_sole ds@darksole.vip. While contributions from others are gratefully acknowledged, all intellectual property rights remain with the author. The models, algorithms, processes, products, methodologies, and concepts described herein are licenced exclusively for commercial use by the Klima Protocol. No other party may implement, copy, modify, or derive works from these materials without explicit written permission from the author.\n© 2025 dark_sole. All rights reserved."
  },
  {
    "objectID": "index.html#sec-prologue",
    "href": "index.html#sec-prologue",
    "title": "Klima 2.0",
    "section": "1 Prologue",
    "text": "1 Prologue\nKlima 2.0 is an autonomous, rules-based coordination protocol designed to support the retirement of carbon credits through transparent pricing, continuous execution, and onchain settlement.\nIt is not a financial product, investment vehicle, or asset management system, but a piece of market infrastructure that enables carbon supply and retirement demand to interact under predefined conditions.\nThe protocol operates through a dual-token architecture that facilitates coordination without discretionary control: kVCM functions as the internal unit of account and pricing reference for protocol-facilitated carbon retirement, while K2 provides signalling inputs related to system capacity. Together, these tokens inform protocol parameters through deterministic smart-contract logic. This architecture enables the protocol to:\n\nprice and intake eligible, tokenised carbon credits according to transparent, onchain rules;\nmake acquired credits available exclusively for irreversible retirement;\ncoordinate liquidity provision and participation incentives required for continuous operation.\n\nParticipant actions such as locking tokens, signalling preferences, or providing liquidity serve as non-custodial inputs into a coordination mechanism that adjusts protocol parameters within predefined bounds. These inputs do not confer ownership rights, redemption rights, or claims on protocol-held carbon, nor do they constitute discretionary management of assets.\nThe protocol consists of three interdependent functional layers:\n\na carbon inventory layer that holds credits solely for the purpose of facilitating retirement;\na governance layer that aggregates participant signals to inform pricing and intake parameters; and\na liquidity layer that supports entry and exit from the system through external markets.\n\nThese layers are designed to operate together as a self-contained system, adjusting to observable supply and retirement demand without reliance on external oracles, manual intervention, or fee-extractive intermediaries.\nKlima 2.0 abstracts complex carbon market interactions into a transparent and auditable execution framework, enabling participants to interact with carbon retirement infrastructure directly, programmatically, and on equal terms.\nAny economic effects arising from protocol activity result from predefined rules and market interaction, rather than from asset ownership, portfolio management, or profit extraction."
  },
  {
    "objectID": "index.html#sec-klima-2.0",
    "href": "index.html#sec-klima-2.0",
    "title": "Klima 2.0",
    "section": "2 Klima 2.0",
    "text": "2 Klima 2.0\nKlimaDAO launched in 2021 on the Polygon blockchain as an early experiment in applying tokenisation and onchain liquidity to voluntary carbon markets. The initial design centred on the KLIMA token and a treasury-based mechanism intended to bootstrap liquidity and participation in a nascent onchain carbon ecosystem.\nThat first iteration played a meaningful role in demonstrating that carbon credits could be represented, transferred, and retired using blockchain infrastructure. It also catalysed the development of a broader ecosystem of tools and services, including integrations with multiple carbon registries, marketplaces and point-of-sale interfaces, APIs for third-party applications, and direct onchain issuance by project developers.\nOver time, it became clear that the original architecture was not well suited to serving large-scale, enterprise carbon buyers or to supporting continuous, rules-based market operation without manual intervention. In particular, treasury-centric designs introduced complexity, opacity, and governance challenges that limited scalability and operational clarity.\nKlima 2.0 is a ground-up redesign informed by these lessons. Rather than relying on treasury management or discretionary allocation, the new protocol is structured as neutral, non-extractive market infrastructure focused exclusively on facilitating carbon retirement through transparent pricing, programmatic settlement, and open participation.\nThe Klima 2.0 protocol replaces treasury-backed mechanisms with a rules-based coordination model that uses protocol-native tokens to parameterise pricing bounds, intake capacity, and participation incentives. Carbon credits handled by the protocol are acquired solely to fulfil retirement demand and are not held, traded, or managed for financial gain.\nThis shift reflects a deliberate move away from capital-centric designs toward infrastructure that prioritises auditability, predictability, and long-term operational resilience. Klima 2.0 is intended to function as a shared execution layer for carbon markets, enabling suppliers, buyers, and integrators to interact under predefined conditions without reliance on discretionary intermediaries.\n\n2.1 Protocol Tokens\nKlima 2.0 operates using two protocol-native tokens, kVCM and K2, which together enable rules-based coordination of pricing, capacity, and participation within the system. These tokens do not confer ownership rights, redemption rights, or claims on protocol-handled carbon, and do not represent investment interests.\nkVCM functions as the internal unit of account and pricing reference for protocol-facilitated carbon retirement, while K2 provides signalling inputs related to system capacity. Both tokens are used exclusively to parameterise protocol behaviour through deterministic smart-contract logic.\nkVCM tokens set core allocation choices, whereas K2 acts as the calibration mechanism for inventory development.\n\n\n2.2 High-Level Architecture\nKlima 2.0 is composed of three interdependent functional layers that together support continuous, non-discretionary operation:\n\nCarbon Inventory Layer:\n\nAccumulates carbon credits by minting kVCM.\nSells carbon certificates by burning kVCM.\nPrices carbon based on the system’s code.\n\nCarbon credits handled by the protocol cannot be withdrawn, transferred, or resold.\nGovernance Layer:\n\nkVCM holders may time-lock their kVCM for a fixed time period and become eligible to select carbon assets for the inventory.\nThis action creates a kVCM Base Accrual curve, which is distributed to the time-locked holders. This is utilised to derive discount rates and governance weightings.\n\nLiquidity Layer:\n\nkVCM and K2 holders are able to pair their tokens together, or in the case of kVCM with USDC, in order to generate liquidity fees.\nStaking the resulting liquidity provider tokens may generate a share of protocol incentives.\nLiquidity locked in the kVCM/K2 liquidity pool participates in general governance alongside time-locked kVCM holders.\n\n\nThese layers operate together as a self-contained system that responds only to its own observable state, without reliance on external oracles or manual intervention.\n\n\n2.3 Economics and Incentives\n\n2.3.1 kVCM Synthetic Yield\nkVCM emits a continuous yield rewarding:\n\nTime-locked kVCM holders (‘kVCM Base Accrual’).\nUser-locked K2 holders (‘kVCM Risk Premium’).\nBoth kVCM and K2 stakers, i.e. liquidity providers who staked their liquidity provider tokens (‘kVCM Risk Premium’).\n\nThe proportions and quantities are dynamic depending on the system state.\n\n\n2.3.2 K2 Incentives\nThe expansion of the K2 token supply is allocated to stakeholders below in varying quantities depending on system balances.\n\nTime-locked kVCM holders.\nUser-locked K2 holders.\nBoth kVCM and K2 stakers.\n\n\n\n\n2.4 Portfolio Manager\nAt the core of the platform, the Portfolio Manager accumulates, trades and distributes its carbon portfolio driven by parameters determined from collective token holder actions (and inaction).\n\n\n\n\n\n\nFigure 1: Klima 2.0 Portfolio Manager.\n\n\n\nThe Portfolio Manager purchases carbon credits and sells offset certificates by pre-defined classification called carbon class. It does not sell carbon credits.\nToken holders collectively set the risk parameters for the pricing of each class by defining:\n\nPortfolio weighting.\nCapacity curve and spreads.\n\nAdditional global parameters are similarly determined:\n\nForward-delivery discount rates.\nkVCM synthetic yield curve creating incentives for portfolio selection, liquidity provision and risk management contributions.\n\nThere are no oracles or external inputs required for Klima 2.0 as it is fully autonomous and responds to its own native state of token balances.\n\n\n2.5 Tokens\n\n2.5.1 Risk-Balanced Asset Token: kVCM\nkVCM represents core ownership of the portfolio assets, and is designed to flex between asset and growth value drivers depending on token-holder activity.\nkVCM has no maximum supply but inflates upon carbon credit accumulation, and contracts upon issuance of carbon offset certificates.\n\nWhen time-locked for fixed maturities:\n\nOptionally selects carbon classes for portfolio weighting and pricing (‘active’).\nSets the forward discount rate for carbon portfolio acquisition from the collective time locking pattern over time.\nGenerates a synthetic yield of kVCM based on the forward curve.\nParticipates in governance for whitelisting carbon assets.\n\nTransactional usage:\n\nMint: New kVCM is issued by the Portfolio Manager to purchase new carbon credits for the portfolio.\nBurn: kVCM are retired by the Portfolio Manager to issue carbon offset certificates.\n\nStaked liquidity:\n\nGenerates a kVCM Risk Premium, which is a time-based relative share of the kVCM synthetic yield reflecting the risks taken to support the price of platform capital.\n\n\nNoting that the tokens can delegate utility as required.\n\n\n\n\n\n\nFigure 2: Automated Asset Manager token utility.\n\n\n\n\n\n2.5.2 Risk Governance Token: K2\nK2 is a fixed-supply token issued programmatically over time with a dynamic allocation for K2 Incentives.\n\nWhen user-locked:\n\nShapes the pricing curve and spread of kVCM.\nDetermines the kVCM Risk Premium for staked liquidity providers.\nGenerates a share of the kVCM Risk Premium.\nReceives K2 Incentives.\n\nStaked Liquidity:\n\nGenerates a share of the kVCM Risk Premium.\nParticipates in governance.\nReceives K2 Incentives.\n\n\n\n\n2.5.3 Utility Functions\nThe kVCM token has two utility functions which are not independent:\n\n\n\n\n\n\nFigure 3: kVCM utility functions.\n\n\n\n\nTime lock: The kVCM token is locked for a specific period of time representing a liquidity preference for the holder in return for yield (‘kVCM base accrual’). This cannot be amended.\nPrice allocation: Collective selection of carbon classes by kVCM allocations determines the instantaneous price ratio for kVCM token issuance. This selection can be amended and withdrawn at any time to allow price modulation for the platform of its carbon assets.\n\nThe K2 token also has two utility functions:\n\nUser lock: The K2 token remains locked for at least 24 hours.\nRisk allocation: collective selection of carbon classes by K2 allocations determines the rate of issuance or price curve of kVCM for the specified carbon class, as well as the retirement burning rate.\n\nBoth tokens facilitate the carbon market to function efficiently with the kVCM token responsible for portfolio selection and pricing, and the K2 token modulating capacity and risk.\n\n\n\n2.6 Initialisation of the kVCM Token\nThe Klima Protocol has approximately 20 million tonnes of carbon credits in its treasury as assets, a part of which will be used to create the initial issuance of kVCM tokens upon launch of Klima 2.0.\n\n\n\n\n\n\n\n\n\n\n\nToken\nAmount\nNotes\n\n\n\n\nkVCM\nA Token\n20 million\n\nSupply expands and contracts perpetually.\n87.5% of initial supply available to existing KLIMA holders.\nInitially created approximately on a 1:1 basis with carbon tonnes held.\nIssues on carbon received, and burns on barbon retired.\n\n\n\nK2\nG Token\n100 million\n\nFixed supply.\n40% put into programmatic issuance as K2 Incentives yield over time.\n40% for existing KLIMA holders.\n\n\n\n\n\n\nTable 1: Token Summary\n\n\n\n\n\n2.7 End Users\n\nCarbon Credit Sellers\nThose wishing to monetise spot- or forward-delivery classes of carbon.\nPortfolio Manager: Continuously acquires carbon credits using an autonomous pricing strategy based on carbon class, delivery and token balances, issuing new kVCM tokens as consideration to build the carbon portfolio.\nOffset Buyers\nThose wishing to obtain carbon offset certificates by retiring carbon credits from the portfolio.\nPortfolio Manager: Continuously sells carbon offset certificates, by burning kVCM tokens and issuing carbon offset certificates by retiring the quantity in the registry.\nInvestors\nThose who wish to own a liquid or yielding locked fixed-maturity financial exposure to a basket of carbon assets.\nTime-Locked Market: Provides a daily time-based yield for those time-locking kVCM tokens called Base Accrual.\nLiquidity Providers\nThose who wish to generate liquidity fees on their portfolio of Klima 2.0 assets coupled together or with USDC.\nLiquidity Market: Staked liquidity providers are incentivised by the kVCM Risk Premium calculated from system metrics to compensate them for risk.\nActive Portfolio Optimisation\nK2 and kVCM asset selection: The incentives and allocations are designed for those who wish to participate in overall risk management to collectively resolve for the optimal portfolio risks.\n\n\n\n2.8 Automated Asset Manager Highlights\n\nDecentralised architecture:\nThe Automated Asset Manager is smart-contract based, fully autonomous as to pricing and distribution of its assets with governance power held by risk-based capital.\nAdverse selection:\nThe Automated Asset Manager does not permit the direct purchase of carbon credits from its portfolio (only carbon offset certificates).\nLiquid carbon:\nUsers with liquid carbon credits can always access carbon offset certificates through the registry, hold the specific carbon credits or sell back to the Automated Asset Manager if required. Secondary markets and utility for liquid carbon credits may emerge over time.\nImplied spreads:\nThe Automated Asset Manager purchases carbon at relative discounts based on capacity pricing and forward discount rates folding natural returns into the portfolio capital.\nDual token structure:\nWhilst the kVCM token reflects asset economics, the K2 token is essential for optimising pricing capacity and in return maximising risk-adjusted spreads for the portfolio. Since its earnings power is a function of the kVCM token value, its role as this spread optimiser is truly economically aligned and as such fundamental values of kVCM and K2 are highly correlated."
  },
  {
    "objectID": "index.html#sec-core-economic-pillars",
    "href": "index.html#sec-core-economic-pillars",
    "title": "Klima 2.0",
    "section": "3 Core Economic Pillars",
    "text": "3 Core Economic Pillars\nFrom this Section, we refer to kVCM and K2 tokens as A and G respectively.\nThe three tenets of Klima 2.0 enable the model to find equilibrium through continuous dynamic feedback loops and system balances. There is no oversight or centralised management entity with discretionary powers.\n\nTime-Locked Market: A token holders stake tokens until a set expiry to create floating yield time locks and have the ability to select carbon classes for portfolio weighting.\n\nThe collective temporal staking pattern produces a Synthetic Yield curve in A tokens to reward time-locked token holders, as well as price the forward curve for the AAM.\nOnly A tokens participate in the Time-Locked Market.\n\nPortfolio Manager: The Portfolio Manager swaps its own token A for carbon credits C (in) or carbon offset certificates C* (out) to build a portfolio of carbon credits.\n\nBoth time-locked A and user-locked G are used in the portfolio manager whereby allocating A determines the pricing of any given carbon class, and allocating G determines the rate of acquisition (and disposal).\nOnly time-locked A tokens can participate in portfolio weighting although it is not mandatory.\nForward-delivery carbon (for a set of fixed dates out to 10 years) is transacted simultaneously with spot liquid carbon.\n\nLiquidity Market: Here the tokens are traded in two core liquidity pairs with various incentives available to staked liquidity providers (LPs), including a Risk Premium generated by the Time-Locked Market synthetic yield.\n\nAG: Native token swap A and G.\nAQ: The asset token A with USDC Q.\n\nThe Liquidity Market provides the complementary facility to the Time-Locked Market and the critical relationship between the native tokens and the hard currency of USDC.\n\nThe Klima 2.0 system enables each participant in the various economic pillars to act in the interests of their own capital and utility, which through the harmonic model, enables price discovery, liquidity and stability for carbon trading which creates positive reinforcement cycles as catalysts for growth and scale.\n\n3.1 Time-Locked Market\nHolders of A can time-lock their token until a maturity from the set of standard maturities. Time locks expire every 90 days on a rolling basis. There are always 40 maturities extending out to approximately 10 years.\n\nForward curve: Aggregate time-locking determines the shape of the discount curve of the A token with regards to its purchasing rate of forward-delivery carbon.\nSynthetic yield: Time-locked A token holders receive a floating yield of new A tokens following the shape of this discount curve called Base Accrual. Base Accrual is calculated daily and accumulates to the principal.\nLiquidity: There is no early unlocking; all principal and accumulated yield is released only at time lock expiration.\n\nG tokens are not involved in the Time-Locked Market. The forward curve is agnostic to carbon class although only time-locked A token holders can allocate their token to carbon classes for portfolio pricing.\n\n3.1.1 Synthetic Yield and Forward-Delivery Curve\nDefining:\n\nS: Total time-locked A tokens expressed as a proportion of the outstanding supply of A.\nS_t: Total A tokens time-locked in maturity bucket t, expressed as a proportion of the outstanding supply of A, where {\\sum S_t = S}, and t is the index of standard maturities t \\in \\{1, 2, 3, \\dots, 40\\}.\nE_t: Time to expiry expressed in years.\n\nCalculating curve parameters D and C:\n\nD = \\frac{1}{S} \\sum_{t=1}^{40} S_t \\, E_t\n\\tag{1}\n\nC = \\frac{1}{S} \\sum_{t=1}^{40} S_t \\, E_t^2\n\\tag{2}\nThe shape of the synthetic yield curve is produced:\n\n\\gamma_t = \\max \\left( \\frac{E_t}{D} - \\frac{E_t^2}{2 \\, C}, \\, 0 \\right)\n\\tag{3}\nNormalising \\gamma_t to \\hat \\gamma_t:\n\n\\hat \\gamma_t = \\frac{\\gamma_t}{\\sum_{t=1}^{40} \\gamma_t}\n\\tag{4}\nWith the cumulative sum of the normalised values expressed as \\Gamma_t:\n\n\\Gamma_t = \\sum_{i=1}^t \\hat \\gamma_i \\quad \\text{for } t = 1, \\dots, 40\n\\tag{5}\nThe zero-coupon yield curve Z_t is solved:\n\nZ_t = (1 - S) \\, \\frac{\\Gamma_t}{E_t}\n\\tag{6}\nWhereupon, the discount rate B_t that forms the forward-delivery curve is derived:\n\nB_t = \\exp(-Z_t \\, E_t)\n\\tag{7}\nThe yield due on time-locked A tokens is calculated daily and added to the staked principal, hence the daily yield for each time bucket is calculated:\n\nY_t = \\exp \\left( \\frac{Z_t}{365} \\right) - 1\n\\tag{8}\nHence, any time-locked A stake S_t will increase by \\Delta S_t:\n\n\\Delta S_t = S_t \\, Y_t\n\\tag{9}\nWith the total A tokens created on a daily basis for time-locked inflation as\n\nR = \\sum_{t=1}^{40} \\Delta S_t\n\\tag{10}\n\n\n\nviewof inputS = Inputs.range([1e-4, 1], {\n  label: tex`\\text{Time-Locked } S`,\n  step: 1e-4,\n  value: 0.55,\n});\nviewof inputD = Inputs.range([0.25, 10], {\n  label: tex`\\text{Parameter } D`,\n  step: 0.01,\n  value: 4.69,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction constAreaLinear(range, area, inputSlope, slopeFactor = 0.007) {\n  if (range.length === 1) {\n    return [area];\n  }\n\n  let y1 = 0;\n  let y2 = range.length - 1;\n  let slope = slopeFactor * Math.atanh(inputSlope);\n  let intercept = area / range.length;\n\n  if (Math.abs(slope) &gt; 2 * intercept / (y2 - y1 - 1)) {\n    const yExactShift = Math.sqrt(Math.abs(2 * area / slope));\n    const yRoundShift = Math.max(1, Math.round(yExactShift));\n    if (slope &gt; 0) {\n      y1 = y2 - yRoundShift;\n    } else {\n      y2 = y1 + yRoundShift;\n    }\n    slope = Math.sign(slope) * 2 * area / Math.pow((y2 - y1), 2);\n    intercept = Math.abs(slope) * (y2 - y1 - 1) / 2;\n  }\n\n  const yConstArea = [];\n  for (let i = 0; i &lt; range.length; i++) {\n    const y = i - (y1 + y2) / 2;\n    yConstArea.push(Math.max(0, slope * y + intercept));\n  }\n\n  return yConstArea;\n}\n\n\n\n\n\n\n\nvecE = d3.range(0.25, 10.1, 0.25);\n\nscaleE = d3.scaleLinear(d3.extent(vecE), [-1, 1]);\n\nvecS = constAreaLinear(vecE, 0.55, scaleE(inputD)).map(\n  x =&gt; x * inputS / 0.55,\n);\n\nvecReverseCumsumS = d3.cumsum(vecS.slice().reverse()).reverse();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction dotProduct(v, w) {\n  if (v.length !== w.length) {\n    throw new Error(\"Vectors must have the same length\");\n  }\n  return v.reduce((acc, val, i) =&gt; acc + val * w[i], 0);\n}\n\nfunction weightedArithmeticMean(v, weights) {\n  return dotProduct(v, weights) / d3.sum(weights);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparamD = weightedArithmeticMean(vecE, vecS);\n\n\n\n\n\n\n\nparamC = weightedArithmeticMean(vecE.map(e =&gt; e * e), vecS);\n\n\n\n\n\n\n\nfunction computeGamma(vecE, paramD, paramC) {\n  const twoC = 2 * paramC;\n  return vecE.map(e =&gt; Math.max(0, e/paramD - e*e/twoC));\n}\n\n\n\n\n\n\n\nvecGamma = computeGamma(vecE, paramD, paramC);\n\n\n\n\n\n\n\nfunction normalize(v) {\n  const sum = d3.sum(v);\n  return v.map(val =&gt; val / sum);\n}\n\n\n\n\n\n\n\nvecNormGamma = normalize(vecGamma);\n\n\n\n\n\n\n\nvecCumSumGamma = d3.cumsum(vecNormGamma);\n\n\n\n\n\n\n\nfunction computeZ(paramS, vecCumSumGamma, vecE) {\n  return vecCumSumGamma.map((g, t) =&gt; (1 - paramS) * g / vecE[t]);\n}\n\n\n\n\n\n\n\nvecZ = computeZ(inputS, vecCumSumGamma, vecE);\n\n\n\n\n\n\n\nfunction computeB(vecZ, vecE) {\n  return vecZ.map((z, t) =&gt; Math.exp(-z * vecE[t]));\n}\n\n\n\n\n\n\n\nvecB = computeB(vecZ, vecE);\n\n\n\n\n\n\n\nfunction computeY(vecZ) {\n  return vecZ.map(z =&gt; Math.expm1(z));\n}\n\n\n\n\n\n\n\nvecY = computeY(vecZ);\n\n\n\n\n\n\n\nparamI = dotProduct(vecS, vecY);\n\n\n\n\n\n\n\nyieldData = {\n   const yieldData = [];\n   for (let t = 3; t &lt; vecE.length; t += 4) {\n      yieldData.push({\n         key: \"Stake A\",\n         value: 100 * d3.sum(vecS.slice(t - 3, t + 1)),\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Yield Term Structure\",\n         value: 100 * vecZ[t],\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Real Yield\",\n         value: 100 * (vecZ[t] - paramI),\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Discount Curve\",\n         value: 100 * vecB[t],\n         time: vecE[t],\n      });\n      yieldData.push({\n         key: \"Cumulative Stake A\",\n         value: 100 * vecReverseCumsumS[t - 3],\n         time: vecE[t],\n      });\n   }\n   return yieldData;\n};\ngetStake = d =&gt; d.key === \"Stake A\" ? d.value : NaN;\ngetYieldTerm = d =&gt; d.key === \"Yield Term Structure\" ? d.value : NaN;\ngetRealYield = d =&gt; d.key === \"Real Yield\" ? d.value : NaN;\ngetDiscount = d =&gt; d.key === \"Discount Curve\" ? d.value : NaN;\ngetCumStake = d =&gt; d.key === \"Cumulative Stake A\" ? d.value : NaN;\n\nstringS = \"Total Stake = \" + inputS.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 },\n);\nstringI = \"Inflation = \" + paramI.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 2, maximumFractionDigits: 2 },\n);\nstringD = `D = ${paramD.toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n)} years`;\nstringC = `√C = ${Math.sqrt(paramC).toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n)} years`;\n\nyieldParams = [\n  { key: stringD, time: paramD },\n  { key: stringC, time: Math.sqrt(paramC) },\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: d3.schemeCategory10,\n    domain: [\"Stake A\", \"Yield Term Structure\", \"Real Yield\", stringD, stringC],\n  },\n  x: {\n    ticks: d3.range(1, 11),\n    domain: [0.25, 10.45],\n    label: \"Time to Expiry (Years)\",\n  },\n  y: {\n    domain: [\n      0,\n      Math.max(d3.max(yieldData, getStake), d3.max(yieldData, getYieldTerm)),\n    ],\n    grid: true,\n  },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Stake A by Maturity (%)\" }),\n    Plot.axisY({ anchor: \"right\", label: \"Yield Rates (%)\" }),\n    Plot.rectY(yieldData, {\n      x1: d =&gt; d.time - 0.45,\n      x2: d =&gt; d.time + 0.45,\n      y: getStake,\n      fill: \"key\",\n    }),\n    Plot.ruleX(yieldParams, {\n      x: \"time\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.lineY(yieldData, { x: \"time\", y: getYieldTerm, stroke: \"key\" }),\n    Plot.dotY(yieldData, { x: \"time\", y: getYieldTerm, fill: \"key\" }),\n    Plot.lineY(yieldData, { x: \"time\", y: getRealYield, stroke: \"key\" }),\n    Plot.dotY(yieldData, { x: \"time\", y: getRealYield, fill: \"key\" }),\n  ],\n});\n\n\n\n\n\n\n\n\n(a) Yield (, ).\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [8, 5, 3, 4].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"Cumulative Stake A\", \"Discount Curve\", stringD, stringC],\n  },\n  x: {\n    ticks: d3.range(1, 11),\n    domain: [0.25, 10.45],\n    label: \"Time to Expiry (Years)\"\n  },\n  y: { domain: [0, 100], grid: true },\n  clip: true,\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Cumulative Stake (%)\" }),\n    Plot.axisY({ anchor: \"right\", label: \"Discount (%)\" }),\n    Plot.rectY(yieldData, {\n      x1: d =&gt; d.time - 0.45,\n      x2: d =&gt; d.time + 0.45,\n      y: getCumStake,\n      fill: \"key\",\n    }),\n    Plot.ruleX(yieldParams, {\n      x: \"time\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.lineY(yieldData, { x: \"time\", y: getDiscount, stroke: \"key\" }),\n    Plot.dotY(yieldData, { x: \"time\", y: getDiscount, fill: \"key\" }),\n  ],\n});\n\n\n\n\n\n\n\n\n(b) Discount rate.\n\n\n\n\n\n\nFigure 4: Example of a Time-Locked Market state.\n\n\n\n\n\n\n\nFor visualising the sensitivity of overall A inflation rates with respect to staking and duration, Figure 5 assumes a single maturity over the staking range to provide an approximation of inflation \\Delta S \\approx Z \\, S.\n\n\n\n\nfunction contrastingTextColor(backgroundColor) {\n  if (d3.hsl(backgroundColor).l &lt; 0.5) {\n    return \"white\";\n  } else {\n    return \"black\";\n  }\n}\n\n\n\n\n\n\n\nfunction computeApproxDeltaA(paramS, paramE) {\n  return paramS * (1 - paramS) / paramE;\n}\n\n\n\n\n\n\n\ninflationData = {\n  const inflationData = [];\n  for (let paramS = 0; paramS &lt; 1.01; paramS += 0.1) {\n    for (let paramE = 1; paramE &lt;= 10; paramE++) {\n      inflationData.push({\n        key: \"ΔA\",\n        e: paramE,\n        s: paramS,\n        value: computeApproxDeltaA(paramS, paramE),\n      });\n    }\n  }\n  return inflationData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, scheme: \"Spectral\", type: \"sequential\", label: \"ΔS\" },\n  x: { ticks: d3.range(1, 10.1, 1), domain: [10.5, 0.5], label: \"Expiry Time E\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Staking S\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(inflationData, {\n      x1: d =&gt; d.e - 0.5,\n      x2: d =&gt; d.e + 0.5,\n      y1: d =&gt; d.s - 0.05,\n      y2: d =&gt; d.s + 0.05,\n      fill: \"value\",\n    }),\n    Plot.text(inflationData, {\n      x: \"e\",\n      y: \"s\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [0, computeApproxDeltaA(0.5, 1)],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 5: A inflation rate from time-locked token yields \\Delta S.\n\n\n\n\n\n3.1.2 Governance Weightings\nGovernance rights, for example the whitelisting (and blacklisting) of carbon classes, and any other matter requiring token stakeholder voting, are allocated to two cohorts:\n\nTime-locked A tokens: S_t\nStaked liquidity in the A-G pair AG (see Section 3.3), defined here as A_{Gt}, representing the quantity of A tokens held in the liquidity pool expressed as a proportion of circulating supply.\n\nVoting power is allocated by time and applied to the respective balance of A:\n\nInitial voting weights for time-locked A tokens v_t:\n\nv_t = Z_t \\, S_t\n  \\tag{11}\nInitial voting weights for staked liquidity w_t:\n\nw_t = Z_t \\, A_{Gt}\n  \\tag{12}\nFinal voting weights for time-locked A tokens V_t:\n\nV_t = \\frac{v_t}{\\sum_{j=1}^{40} (v_j + 2 w_j)}\n  \\tag{13}\nFinal voting weights for staked liquidity W_t:\n\nW_t = \\frac{w_t}{\\sum_{j=1}^{40} \\left( \\frac 1 2 v_j + w_j \\right)}\n  \\tag{14}\n\n\n\n\n3.2 Portfolio Manager\nThe Portfolio Manager’s role of swapping A for carbon is managed through a set of smart contracts driven by allocation choices from the token system, the balances of assets held, and the discount rates generated by the Time-Locked Market.\nThe combined allocations of A and G tokens creates a dynamic pricing matrix by carbon class and by time, enabling spot and forward trading of carbon.\n\n\n\n\n\n\nFigure 6: Klima 2.0 Portfolio Manager.\n\n\n\n\n3.2.1 Purchase Carbon\nUser swaps carbon credits for A tokens.\n\n3.2.1.1 Existing Carbon in the Portfolio\nCarbon classes {i \\in \\{1, 2, 3, \\dots, n\\}} are whitelisted through governance by time-locked A token and staked AG liquidity providers (see Section 3.1.2).\nFor carbon pricing, both A tokens and G tokens may be allocated to specific carbon classes i and these are independent allocations between the two-token systems.\n\n\n\n\n\n\nFigure 7: Token staking class structure.\n\n\n\nFor a carbon class quantity to be sold to the Automated Asset Manager, it must have a strictly positive quantity of A tokens allocated to that carbon class, otherwise there is no price, and the carbon cannot be sold.\nDefining:\n\nC_i: Total tonnes of carbon class i currently held in the portfolio.\nA_i: A tokens allocated to carbon class i expressed as a proportion of the outstanding supply of A tokens, where {\\sum A_i = A}.\nG_i: G tokens allocated to carbon class i expressed as a proportion of the outstanding supply of G Tokens.\nC_{it}: The quantity of carbon class i held in the Automated Asset Manager deliverable per maturity t where C_{i0} reflects the liquid quantity.\n\nIn order to determine the present-value quantity of carbon, \\bar C_i, we apply the discount curve from Equation 7 to the liquidity schedule and sum the discounted holdings:\n\n\\bar C_i = C_{i0} + \\sum_{t=1}^{40} B_t \\, C_{it}\n\\tag{15}\n\n\n\nviewof inputCi0 = Inputs.range([0, 1], {\n  label: tex`\\text{Portfolio } C_{i0}`,\n  step: 1e-3,\n});\nviewof inputLiqShape = Inputs.range([-1, 1], {\n  label: tex`\\text{Schedule shape}`,\n  step: 1e-3,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvecCi = constAreaLinear(vecE, 1 - inputCi0, inputLiqShape, 0.01);\n\nparamBarCi = inputCi0 + dotProduct(vecB, vecCi);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncarbonHeldData = {\n  const carbonHeldData = [];\n  carbonHeldData.push({\n    key: \"Liquidity Schedule\",\n    value: 100 * inputCi0,\n    time: 0,\n  });\n  for (let t = 3; t &lt; vecE.length; t += 4) {\n    carbonHeldData.push({\n      key: \"Liquidity Schedule\",\n      value: 100 * d3.sum(vecCi.slice(t - 3, t + 1)),\n      time: vecE[t],\n    });\n    carbonHeldData.push({\n      key: \"Discount Curve\",\n      value: 100 * vecB[t],\n      time: vecE[t],\n    });\n  }\n  return carbonHeldData;\n};\ngetLiqSchedule = d =&gt; d.key === \"Liquidity Schedule\" ? d.value : NaN;\n\nstringBarCi = `Present-Value Carbon C̄ᵢ = ${paramBarCi.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n)}`;\n\nheldCarbonParam = [{ key: stringBarCi, value: 100 * paramBarCi }];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [2, 5, 6].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"Liquidity Schedule\", \"Discount Curve\", stringBarCi],\n  },\n  x: {\n    label: \"Time to Expiry (Years)\",\n    labelAnchor: \"right\",\n    labelArrow: true,\n  },\n  y: { domain: [0, 100], grid: true },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Quantity of Carbon (%)\" }),\n    Plot.axisY({ anchor: \"right\", label: \"Discount (%)\" }),\n    Plot.rectY(carbonHeldData, {\n      x1: d =&gt; d.time - 0.45,\n      x2: d =&gt; d.time + 0.45,\n      y: getLiqSchedule,\n      fill: \"key\",\n    }),\n    Plot.ruleY(heldCarbonParam, {\n      y: \"value\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.lineY(carbonHeldData, { x: \"time\", y: getDiscount, stroke: \"key\" }),\n    Plot.dotY(carbonHeldData, { x: \"time\", y: getDiscount, fill: \"key\" }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 8: Carbon held in the portfolio.\n\n\n\n\n\n\n\nSimilarly, taking \\Delta C_{it} as the quantity of carbon i to be sold with a specific maturity index t:\n\n\\Delta \\bar C_i = \\Delta C_{i0} + \\sum_{t=1}^{40} B_t \\, \\Delta C_{it}\n\\tag{16}\nOnce standardised by the discount curve, trades can be aggregated in the same class for the defined trade or auction period.\n\n\n\nviewof inputDeltaCi = Inputs.range([0, 1], {\n  label: tex`\\text{Purchased } \\Delta C_i`,\n  step: 1e-3,\n  value: 1,\n});\nviewof inputEt = Inputs.range([0, 10], {\n  label: tex`\\text{Expiry } E_t \\text{ (years)}`,\n  step: 1,\n  value: 6,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeDeltaCi0(deltaCi, t) {\n  return t === 0 ? deltaCi : 0;\n}\n\nfunction computeVecDeltaCi(deltaCi, t) {\n  const vecDeltaCi = Array(40).fill(0);\n  if (t !== 0) {\n    vecDeltaCi[t - 1] = deltaCi;\n  }\n  return vecDeltaCi;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparamMaturityIdx = 4 * inputEt;\n\nparamDeltaCi0 = computeDeltaCi0(inputDeltaCi, paramMaturityIdx);\n\nvecDeltaCi = computeVecDeltaCi(inputDeltaCi, paramMaturityIdx);\n\nparamDeltaBarCi = paramDeltaCi0 + dotProduct(vecB, vecDeltaCi);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncarbonBuyData = {\n  const carbonBuyData = [];\n  carbonBuyData.push({\n    key: \"Carbon Bought by AAM\",\n    value: 100 * paramDeltaCi0,\n    time: 0,\n  });\n  for (let t = 3; t &lt; vecE.length; t += 4) {\n    carbonBuyData.push({\n      key: \"Carbon Bought by AAM\",\n      value: 100 * d3.sum(vecDeltaCi.slice(t - 3, t + 1)),\n      time: vecE[t],\n    });\n    carbonBuyData.push({\n      key: \"Discount Curve\",\n      value: 100 * vecB[t],\n      time: vecE[t],\n    });\n  }\n  return carbonBuyData;\n};\ngetCarbonBought = d =&gt; d.key === \"Carbon Bought by AAM\" ? d.value : NaN;\n\nstringDeltaBarCi = \"Present-Value Carbon Bought by AAM ΔC̄ᵢ = \" +\n        paramDeltaBarCi.toLocaleString(\n          \"en-GB\",\n          {\n            style: \"percent\",\n            minimumFractionDigits: 1,\n            maximumFractionDigits: 1,\n          },\n        );\nboughtCarbonParam = [{ key: stringDeltaBarCi, value: 100 * paramDeltaBarCi }];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [3, 5, 7].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"Carbon Bought by AAM\", \"Discount Curve\", stringDeltaBarCi],\n  },\n  x: {\n    label: \"Time to Expiry (Years)\",\n    labelAnchor: \"right\",\n    labelArrow: true,\n  },\n  y: { domain: [0, 100], grid: true },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Quantity of Carbon (%)\" }),\n    Plot.axisY({ anchor: \"right\", label: \"Discount (%)\" }),\n    Plot.rectY(carbonBuyData, {\n      x1: d =&gt; d.time - 0.45,\n      x2: d =&gt; d.time + 0.45,\n      y: getCarbonBought,\n      fill: \"key\",\n    }),\n    Plot.ruleY(boughtCarbonParam, {\n      y: \"value\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.lineY(carbonBuyData, { x: \"time\", y: getDiscount, stroke: \"key\" }),\n    Plot.dotY(carbonBuyData, { x: \"time\", y: getDiscount, fill: \"key\" }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 9: Carbon bought by the Portfolio Manager.\n\n\n\n\n\n\n\nWhere \\Delta \\bar C_i is expressed as the relative increment to its respective pool balance, the amount of A tokens issued to pay for carbon, \\Delta A, expressed as a proportion of current supply, is determined as:\n\n\\ln(1 + \\Delta A) =\n  \\left( A_i - \\frac{A_i^2 \\, (1 - G_i)^2}{2} \\right) \\ln(1 + \\Delta \\bar C_i)\n\\tag{17}\nDenoting the expression on the right hand side of Equation 17 as \\mathsf{RHS}:\n\n\\Delta A = \\exp(\\mathsf{RHS}) - 1\n\\tag{18}\nFinally, \\Delta A is applied to the outstanding supply of A to solve for token quantities.\nFigure 10 illustrates the G token’s capacity to maintain the initial portfolio pricing of the A token. The data has been normalised in Figure 11 to \\Delta \\bar C_i \\, A_i.\n\n\n\nviewof inputDeltaBarCi = Inputs.range([0.01, 1], {\n  label: tex`\\text{Purchased } \\Delta \\bar C_i`,\n  step: 0.01,\n  value: 1,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeDeltaA(Ai, Gi, deltaCi) {\n  return Math.expm1((Ai - (Ai**2 * (1 - Gi)**2 / 2)) * Math.log1p(deltaCi));\n}\n\n\n\n\n\n\n\npricingData = {\n  const pricingData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    pricingData.push({\n      key: \"ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    pricingData.push({\n      key: \"Normalised ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      pricingData.push({\n        key: \"ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaA(paramAi, paramGi, inputDeltaBarCi),\n      });\n      pricingData.push({\n        key: \"Normalised ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaA(paramAi, paramGi, inputDeltaBarCi) /\n                (inputDeltaBarCi * paramAi),\n      });\n    }\n  }\n  return pricingData;\n};\ngetDeltaA = d =&gt; d.key === \"ΔA\" ? d.value : NaN;\ngetNormDeltaA = d =&gt; d.key === \"Normalised ΔA\" ? d.value : NaN;\n\nstringInputDeltaBarCi = inputDeltaBarCi.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `ΔA, where ΔC̄ᵢ = ${stringInputDeltaBarCi}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(pricingData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getDeltaA,\n    }),\n    Plot.text(pricingData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeDeltaA(0.1, 1, inputDeltaBarCi),\n            computeDeltaA(1, 1, inputDeltaBarCi),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 10: A price curves (\\Delta A).\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `Normalised ΔA, where ΔC̄ᵢ = ${stringInputDeltaBarCi}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(pricingData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getNormDeltaA,\n    }),\n    Plot.text(pricingData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getNormDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeDeltaA(1, 0, inputDeltaBarCi) / inputDeltaBarCi,\n            computeDeltaA(1, 1, inputDeltaBarCi) / inputDeltaBarCi,\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 11: Normalised A price curves.\n\n\n\n\n\n\n\nNoting that the sensitivity to G_i increases as A_i increases and the effects become more pronounced as \\Delta \\bar C_i increases.\n\n\n3.2.1.2 Zero Carbon Scenario\nThere are circumstances when there is zero carbon held in the portfolio for a particular class, i.e. {C_i = 0}, which invalidates the calculation of \\Delta \\bar C_i and a different approach is required.\nTaking \\Delta \\bar C_\\emptyset as the tonnes of carbon tokens (implying an existing balance of 1 tonne), adjusted for forward discounting, to be sold for any carbon class that has a strictly positive A allocation A_\\emptyset, together with G allocation G_\\emptyset:\n\n\\Delta A =\n  \\frac{\\Delta \\bar C_\\emptyset}{1 + \\Delta \\bar C_\\emptyset} \\,\n  \\left( A_\\emptyset - \\frac{A_\\emptyset^2 (1 - G_\\emptyset)^2}{2} \\right)^2\n\\tag{19}\n\n\n\nviewof inputDeltaBarCnull = Inputs.range([1e-1, 1e5], {\n  label: tex`\\text{Purchased } \\Delta \\bar C_\\emptyset`,\n  step: 1e-1,\n  value: 1e2,\n  transform: Math.log,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeZeroCarbonDeltaA(Ai, Gi, deltaCnull) {\n  return (deltaCnull / (1 + deltaCnull)) * (Ai - (Ai**2 * (1 - Gi)**2 / 2))**2;\n}\n\nfunction computeTrueDeltaA(Ai, Gi, barCiTonnes, deltaBarCiTonnes) {\n  if (barCiTonnes === 0) {\n    return computeZeroCarbonDeltaA(Ai, Gi, deltaBarCiTonnes);\n  } else {\n    const deltaBarCi = deltaBarCiTonnes / barCiTonnes;\n    return computeDeltaA(Ai, Gi, deltaBarCi);\n  }\n}\n\nfunction numberOfDigits(x) {\n  return x === 0 ? 1 : (1 + Math.floor(Math.log10(x)));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nzeroCarbonData = {\n  const zeroCarbonData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    zeroCarbonData.push({\n      key: \"ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    zeroCarbonData.push({\n      key: \"Normalised ΔA\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      zeroCarbonData.push({\n        key: \"ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeZeroCarbonDeltaA(paramAi, paramGi, inputDeltaBarCnull),\n      });\n      zeroCarbonData.push({\n        key: \"Normalised ΔA\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeZeroCarbonDeltaA(paramAi, paramGi, inputDeltaBarCnull) /\n                ((inputDeltaBarCnull / (1 + inputDeltaBarCnull)) * paramAi**2),\n      });\n    }\n  }\n  return zeroCarbonData;\n};\n\nstringDeltaBarCnull = inputDeltaBarCnull.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(1, numberOfDigits(inputDeltaBarCnull)),\n    maximumSignificantDigits: Math.max(1, numberOfDigits(inputDeltaBarCnull)),\n  },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `ΔA, where ΔC̄∅ = ${stringDeltaBarCnull} tCO2eq`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(zeroCarbonData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getDeltaA,\n    }),\n    Plot.text(zeroCarbonData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 4, maximumFractionDigits: 4 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeZeroCarbonDeltaA(0.1, 1, inputDeltaBarCnull),\n            computeZeroCarbonDeltaA(1, 1, inputDeltaBarCnull),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 12: A price curves (\\Delta A) in the zero carbon scenario.\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `Normalised ΔA, where ΔC̄∅ = ${stringDeltaBarCnull} tCO2eq`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(zeroCarbonData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getNormDeltaA,\n    }),\n    Plot.text(zeroCarbonData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getNormDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            computeZeroCarbonDeltaA(1, 0, inputDeltaBarCnull) /\n                    (inputDeltaBarCnull / (1 + inputDeltaBarCnull)),\n            computeZeroCarbonDeltaA(1, 1, inputDeltaBarCnull) /\n                    (inputDeltaBarCnull / (1 + inputDeltaBarCnull)),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 13: Normalised A price curves in the zero carbon scenario.\n\n\n\n\n\n\n\n\n\n\n3.2.2 Sell Offset Certificates\nUser swaps A tokens for carbon offset certificates.\n\n3.2.2.1 Weighted Carbon Class\nFor retiring carbon that is weighted, that is for which there is a strictly positive A token allocation, an A token holder can extract the carbon class offset certificate of their choice C_i but the available pool is only the liquid carbon balance, namely the element C_{i0}:\n\n\\ln(1 + \\Delta C_i) =\n  \\frac{-\\ln(1 + \\Delta A)}{A_i + \\frac 1 2 A_i^2 \\, (1 - G_i)^2}\n\\tag{20}\nAs before, denoting the expression on the right hand side of Equation 20 as \\mathsf{RHS}:\n\n\\Delta C_i = \\exp(\\mathsf{RHS}) - 1\n\\tag{21}\n\n\n\nviewof inputDeltaA = Inputs.range([0.001, 0.999], {\n  label: tex`\\text{Burnt } \\Delta A`,\n  step: 0.001,\n  value: 0.1,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeDeltaCi(Ai, Gi, deltaA) {\n  return Math.expm1(-Math.log1p(deltaA) / (Ai + (Ai**2 * (1 - Gi)**2 / 2)));\n}\n\n\n\n\n\n\n\nretirementData = {\n  const retirementData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    retirementData.push({\n      key: \"-ΔCᵢ\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      retirementData.push({\n        key: \"-ΔCᵢ\",\n        ai: paramAi,\n        gi: paramGi,\n        value: -computeDeltaCi(paramAi, paramGi, inputDeltaA),\n      });\n    }\n  }\n  return retirementData;\n};\n\nstringInputDeltaA = inputDeltaA.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 1, maximumFractionDigits: 1 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: `-ΔCᵢ, where ΔA = ${stringInputDeltaA}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(retirementData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: \"value\",\n    }),\n    Plot.text(retirementData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            -computeDeltaCi(1, 0, inputDeltaA),\n            -computeDeltaCi(0.1, 1, inputDeltaA),\n          ],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 14: Proportion of carbon retired.\n\n\n\n\n\n\n\nFigure 14 shows the cost of carbon increasing with A_i and decreasing on G_i.\n\n\n3.2.2.2 Unweighted Carbon Class\nAn offset certificate for a carbon class with a zero A allocation cannot be extracted from the portfolio by swapping in A tokens.\n\n\n3.2.2.3 Liquidation: \\Delta A = 1\nIn the event that 100% of A tokens are placed into the burn mechanism for carbon offset certificates, the balances of all carbon held in the portfolio post-trade are distributed to all G token holders.\nFigure 15 below shows the spread captured on a ‘round trip’ by the system where \\varepsilon is the proportion retained:\n\n\n\nviewof inputDeltaCinitial = Inputs.range([0.001, 1], {\n  label: tex`\\text{Initial }\\Delta C`,\n  step: 0.001,\n  value: 0.1,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeSpread(Ai, Gi, deltaCinitial) {\n  const deltaA = computeDeltaA(Ai, Gi, deltaCinitial);\n  const deltaCfinal = -computeDeltaCi(Ai, Gi, deltaA);\n  return (deltaCinitial - deltaCfinal) / deltaCinitial;\n}\n\n\n\n\n\n\n\nliquidationData = {\n  const liquidationData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    liquidationData.push({ key: \"deltaa\", ai: 0, gi: paramGi, value: NaN });\n    liquidationData.push({ key: \"deltac\", ai: 0, gi: paramGi, value: NaN });\n    liquidationData.push({ key: \"spread\", ai: 0, gi: paramGi, value: NaN });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      const deltaA = computeDeltaA(paramAi, paramGi, inputDeltaCinitial)\n      liquidationData.push({\n        key: \"deltaa\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaA(paramAi, paramGi, inputDeltaCinitial) /\n                inputDeltaCinitial,\n      });\n      liquidationData.push({\n        key: \"deltac\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeDeltaCi(paramAi, paramGi, deltaA) / inputDeltaCinitial,\n      });\n      liquidationData.push({\n        key: \"spread\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeSpread(paramAi, paramGi, inputDeltaCinitial),\n      });\n    }\n  }\n  return liquidationData;\n};\ngetLiqDeltaA = d =&gt; d.key === \"deltaa\" ? d.value : NaN;\ngetLiqDeltaCi = d =&gt; d.key === \"deltac\" ? d.value : NaN;\ngetLiqSpread = d =&gt; d.key === \"spread\" ? d.value : NaN;\n\nstringInputDeltaCinitial = inputDeltaCinitial.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", minimumFractionDigits: 1, maximumFractionDigits: 1 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, computeSpread(1, 0, 1)],\n    type: \"sequential\",\n    label: `Carbon Spread ε, where initial ΔC = ${stringInputDeltaCinitial}`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(liquidationData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getLiqSpread,\n    }),\n    Plot.text(liquidationData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getLiqSpread(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [0, computeSpread(1, 0, inputDeltaCinitial)],\n          d3.interpolateSpectral,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 15: Carbon ‘spread’.\n\n\n\n\n\n\n\nFigure 16 shows the component ‘spread’ contributions on a carbon sale and purchase round trip of a carbon offset certificate.\n\n\n\nInputs.bind(\n  Inputs.range([0.001, 1], {\n    label: tex`\\text{Initial }\\Delta C`,\n    step: 0.001,\n    value: 0.1,\n  }),\n  viewof inputDeltaCinitial,\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: `Component ΔA, where initial ΔC = ${\n      stringInputDeltaCinitial\n    }`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(liquidationData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getLiqDeltaA,\n    }),\n    Plot.text(liquidationData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getLiqDeltaA(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(d3.interpolateSpectral(d.value)),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\n(a) Carbon ‘spread’ component ΔA.\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Greys\",\n    domain: [\n      -1,\n      computeDeltaCi(\n        1,\n        0,\n        computeDeltaA(1, 0, inputDeltaCinitial) / inputDeltaCinitial,\n      ),\n    ],\n    label: `Component ΔC, where initial ΔC = ${\n      stringInputDeltaCinitial\n    }`,\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(liquidationData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: getLiqDeltaCi,\n    }),\n    Plot.text(liquidationData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(getLiqDeltaCi(d)) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential(\n          [\n            -1,\n            computeDeltaCi(\n              1,\n              0,\n              computeDeltaA(1, 0, inputDeltaCinitial) / inputDeltaCinitial,\n            ),\n          ],\n          d3.interpolateGreys,\n        )(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\n(b) Carbon ‘spread’ component ΔC.\n\n\n\n\n\n\nFigure 16: Carbon ‘spread’ components.\n\n\n\n\n\n\n\n\n\n\n\n3.3 Liquidity Markets\nBoth A and G tokens can be used for providing liquidity.\n\n\n\n\n\n\nFigure 17: Token liquidity and pricing structure.\n\n\n\nThere are two core liquidity pools:\n\nAn AAM 50:50 pairing of A and G tokens: pool AG.\nA hard currency USDC denoted as Q paired with A: pool AQ.\n\n\n3.3.1 Liquidity Fees\nThe AQ pool will have its own set of fees in the normal way.1\nThe AG pool has different economics as the assets are highly correlated since they represent the same economy. For this reason, the fees are extremely low.\nBy staking liquidity (liquidity provider tokens) to the standard maturities, both pools may receive a distribution of A tokens determined from the Risk Premium calculation below. This is an additional primary issuance to the Base Accrual already discussed.\n\n\n3.3.2 Risk Premium: Beta Determination\nWe can consider the Time-Locked Market yield as the system’s risk-free rate. In addition to this mechanism, a risky spread is determined that is ultimately paid to the staked liquidity providers of the A and G tokens as compensation for the risk levels assumed.\nAs we have seen, the G token has an impact on risk-pricing of A. As G staking increases, the relationship between the carbon class selected under G_i and the portfolio token A strengthens. We can consider G_i staking as an estimate of residual or idiosyncratic risk in the carbon class and this allows us to calculate a portfolio beta \\beta from the implied betas of each carbon class i.\n\n\\beta = \\sqrt{\\sum_{i=1}^n A_i - A_i \\, (1 - G_i)^2}\n\\tag{22}\nThe portfolio \\beta determines a yield factor for the liquidity pools of A to compensate for the implied risk levels.\nFor intuition, the map in Figure 18 shows the various outputs of the function per carbon class.\n\n\n\n\nfunction computeBeta(vecAi, vecGi) {\n  const beta2 = vecAi.reduce(\n    (acc, Ai, i) =&gt; acc + Ai - Ai * (1 - vecGi[i])**2,\n    0,\n  );\n  return Math.sqrt(beta2);\n}\n\n\n\n\n\n\n\nfunction computeBetai(Ai, Gi) {\n  return Math.sqrt(Ai - Ai * (1 - Gi)**2);\n}\n\n\n\n\n\n\n\nbetaData = {\n  const betaData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    betaData.push({\n      key: \"βᵢ\",\n      ai: 0,\n      gi: paramGi,\n      value: NaN,\n    });\n    for (let paramAi = 0.1; paramAi &lt; 1.01; paramAi += 0.1) {\n      betaData.push({\n        key: \"βᵢ\",\n        ai: paramAi,\n        gi: paramGi,\n        value: computeBetai(paramAi, paramGi),\n      });\n    }\n  }\n  return betaData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    type: \"sequential\",\n    label: \"βᵢ\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Aᵢ\" },\n  y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n  marks: [\n    Plot.frame(),\n    Plot.rect(betaData, {\n      x1: d =&gt; d.ai - 0.05,\n      x2: d =&gt; d.ai + 0.05,\n      y1: d =&gt; d.gi - 0.05,\n      y2: d =&gt; d.gi + 0.05,\n      fill: \"value\",\n    }),\n    Plot.text(betaData, {\n      x: \"ai\",\n      y: \"gi\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(d3.interpolateSpectral(d.value)),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 18: Range of \\beta_i.\n\n\n\nThe table and figure below show an example of the effects on \\beta of allocating large G_i values to small A_i values where the shift in G_i results in a lower \\beta (0.27 from 0.55) with no change to total G and A allocations.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClass\n1\n2\n3\n4\n\\beta\n\n\n\n\nA_i\n0.50\n0.20\n0.10\n0.05\n\n\n\nInitial G_i\n0.30\n0.10\n0.05\n0.01\n\n\n\nInitial \\beta_i^2\n0.2550\n0.0380\n0.0098\n0.0010\n0.5511\n\n\nNew G_i\n0.01\n0.05\n0.10\n0.30\n\n\n\nNew \\beta_i^2\n0.0100\n0.0195\n0.0190\n0.0255\n0.2719\n\n\n\\Delta G_i\n(0.29)\n(0.05)\n0.05\n0.29\n\n\n\n\\Delta \\beta_i^2\n(0.2451)\n(0.0185)\n0.0092\n0.0245\n\n\n\n\n\n\nTable 2: Effect on \\beta from outsized G allocation.\n\n\n\n\n\n\n\narrayAi = [0.5, 0.2, 0.1, 0.05];\narrayInitialGi = [0.3, 0.1, 0.05, 0.01];\narrayNewGi = arrayInitialGi.toReversed();\nbetaContribData = {\n  const betaContribData = [];\n  for (let i = 0; i &lt; arrayAi.length; i++) {\n    const Ai = arrayAi[i];\n    const initialGi = arrayInitialGi[i];\n    const initialBeta2 = computeBetai(Ai, initialGi)**2;\n    const newGi = arrayNewGi[i];\n    const newBeta2 = computeBetai(Ai, newGi)**2;\n    betaContribData.push({ key: \"Initial Gᵢ\", class: i, value: initialGi });\n    betaContribData.push({ key: \"Initial βᵢ²\", class: i, value: initialBeta2 });\n    betaContribData.push({ key: \"New Gᵢ\", class: i, value: newGi });\n    betaContribData.push({ key: \"New βᵢ²\", class: i, value: newBeta2 });\n  }\n  return betaContribData;\n};\ngetInitialG = d =&gt; d.key === \"Initial Gᵢ\" ? d.value : NaN;\ngetInitialBeta2 = d =&gt; d.key === \"Initial βᵢ²\" ? d.value : NaN;\ngetNewG = d =&gt; d.key === \"New Gᵢ\" ? d.value : NaN;\ngetNewBeta2 = d =&gt; d.key === \"New βᵢ²\" ? d.value : NaN;\n\ndomainG = [0, Math.max(d3.max(arrayInitialGi), d3.max(arrayNewGi))];\nrangeBeta2 = [\n  0,\n  Math.max(\n    d3.max(betaContribData, getInitialBeta2),\n    d3.max(betaContribData, getNewBeta2),\n  ),\n];\nscaleG = d3.scaleLinear(domainG, rangeBeta2);\nmapScaleG = x =&gt; x.map(scaleG);\n\nparamInitialBeta = computeBeta(arrayAi, arrayInitialGi);\nparamNewBeta = computeBeta(arrayAi, arrayNewGi);\n\nstringInitialBeta = \"Initial β = \" + paramInitialBeta.toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 4, maximumFractionDigits: 4 },\n);\nstringNewBeta = \"New β = \" + paramNewBeta.toLocaleString(\n  \"en-GB\",\n  { minimumFractionDigits: 4, maximumFractionDigits: 4 },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [\"gray\", \"black\", \"blue\", \"red\"],\n    domain: [\"Initial βᵢ²\", \"New βᵢ²\", \"Initial Gᵢ\", \"New Gᵢ\"],\n  },\n  x: {\n    ticks: d3.range(4),\n    label: \"Aᵢ Over 4 Classes\",\n    tickFormat: d =&gt; arrayAi[d],\n  },\n  y: { domain: rangeBeta2 },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"βᵢ²\" }),\n    Plot.axisY(scaleG.ticks(), { anchor: \"right\", label: \"Gᵢ\", y: scaleG }),\n    Plot.rectY(betaContribData, {\n      x1: d =&gt; d.class - 0.45,\n      x2: d =&gt; d.class,\n      y: getInitialBeta2,\n      fill: \"key\",\n    }),\n    Plot.rectY(betaContribData, {\n      x1: d =&gt; d.class,\n      x2: d =&gt; d.class + 0.45,\n      y: getNewBeta2,\n      fill: \"key\",\n    }),\n    Plot.lineY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getInitialG,\n      stroke: \"key\",\n      strokeDasharray: 4,\n    })),\n    Plot.dotY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getInitialG,\n      fill: \"key\",\n    })),\n    Plot.lineY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getNewG,\n      stroke: \"key\",\n      strokeDasharray: 4,\n    })),\n    Plot.dotY(betaContribData, Plot.mapY(mapScaleG, {\n      x: \"class\",\n      y: getNewG,\n      fill: \"key\",\n    })),\n    Plot.text([stringInitialBeta], { x: 0.5, y: 0.23, fill: d =&gt; \"blue\" }),\n    Plot.text([stringNewBeta], { x: 2.5, y: 0.23, fill: d =&gt; \"red\" }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 19: Example of G allocation on \\beta.\n\n\n\nFigure 19 shows \\beta’s sensitivity to G allocation as a function of A allocation; that is to say that a large G_i stake on a small A_i stake has limited effects (notwithstanding other consequential factors).\n\n\n3.3.3 Allocation of Risk Premium\nThe full issuance of A tokens is depicted below including now the Risk Premium for the liquidity pools accordingly.\n\n\n\n\n\n\nFigure 20: A token flow structure.\n\n\n\n\n\n3.3.4 Share of Risk Premium\nThe Risk Premium allocation is shared between user-locked G tokens, AG. and AQ pools, with shares \\lambda_{GG}, \\lambda_G, and \\lambda_Q respectively.\nDefining:\n\nG_G: Total G tokens in the AG pool, expressed as a proportion of the outstanding supply of G.\nA_G: Total A tokens in the AG pool, expressed as a proportion of the outstanding supply of A.\nA_Q: Total A tokens in the AQ pool, expressed as a proportion of the outstanding supply of A.\n\nThe allocation to user-locked G tokens, \\lambda_{GG}:\n\n\\lambda_{GG} = \\frac{1 - A_Q}{1 + \\left( \\frac{\\sum_{i=1}^{n}{G_i}}{G_G} \\right)^2}\n\\tag{23}\n\n\n\n\nfunction computeLambdaGG(AQ, Gi, GG) {\n  return (1 - AQ) / (1 + (Gi / GG)**2);\n}\n\nfunction changeTranslation(dx, dy) {\n  return function () {\n    const svgTransformList = this.transform.baseVal;\n    if (svgTransformList.length &gt; 1) {\n      throw new Error(\"SVGTransformList must only contain one translation\");\n    }\n    const {e, f} = svgTransformList.consolidate().matrix;\n    return `translate(${e + dx},${f + dy})`;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlambdaGGData = {\n  const lambdaGGData = [];\n  for (let paramGi = 0; paramGi &lt; 1.01; paramGi += 0.1) {\n    for (let paramAQ = 0; paramAQ &lt; 1.01; paramAQ += 0.1) {\n      lambdaGGData.push({\n        key: \"λ\",\n        aq: paramAQ,\n        gi: paramGi,\n        value: computeLambdaGG(paramAQ, paramGi, 1 - paramGi),\n      });\n    }\n  }\n  return lambdaGGData;\n};\n\n\n\n\n\n\n\nplotLambdaGG = {\n  const plotLambdaGG = Plot.plot({\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"λ\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"A  \" },\n    y: { ticks: d3.range(0, 1.01, 0.1), domain: [1.05, -0.05], label: \"Gᵢ\" },\n    marks: [\n      Plot.frame(),\n      Plot.rect(lambdaGGData, {\n        x1: d =&gt; d.aq - 0.05,\n        x2: d =&gt; d.aq + 0.05,\n        y1: d =&gt; d.gi - 0.05,\n        y2: d =&gt; d.gi + 0.05,\n        fill: \"value\",\n      }),\n      Plot.text(lambdaGGData, {\n        x: \"aq\",\n        y: \"gi\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotLambdaGG)\n    .select(\"g[aria-label='x-axis label']\")\n    .select(\"text\")\n      .clone(false)\n      .attr(\"transform\", changeTranslation(-12, 1.5))\n      .attr(\"font-size\", \"0.6em\")\n      .attr(\"font-weight\", \"600\")\n      .text(\"Q\");\n\n  return plotLambdaGG;\n};\n\n\n\n\n\n\n\n\nFigure 21: G stake allocation (assuming G_G = 1 - G_i).\n\n\n\nNoting the relationship between G and \\beta, and particularly if G = 0, \\beta = 0.\nThe residual share, 1 - \\lambda_{GG}, is split between the liquidity pools:\n\n\\lambda_G = (1 - \\lambda_{GG}) \\frac{2 A_G}{2 A_G + A_Q \\sqrt 2}\n\\tag{24}\nFor completeness:\n\n\\lambda_Q = 1 - \\lambda_{GG} - \\lambda_G\n\\tag{25}\n\n\n\n\nfunction computeLambdaG(AQ, AG) {\n  return 2 * AG / (2 * AG + AQ * Math.sqrt(2));\n}\n\n\n\n\n\n\n\nfunction computeLambdaQ(AQ, AG) {\n  return 1 - computeLambdaG(AQ, AG);\n}\n\n\n\n\n\n\n\nlambdaGQData = {\n  const lambdaGQData = [];\n  for (let paramAG = 0; paramAG &lt; 1.01; paramAG += 0.1) {\n    for (let paramAQ = 0; paramAQ &lt; 1.01; paramAQ += 0.1) {\n      if (paramAG + paramAQ &lt; 1.01) {\n        lambdaGQData.push({\n          key: \"Relative 𝗔𝗚 Liquidity Pool Share\",\n          aq: paramAQ,\n          ag: paramAG,\n          value: computeLambdaG(paramAQ, paramAG),\n        });\n        lambdaGQData.push({\n          key: \"Relative 𝗔𝗤 Liquidity Pool Share\",\n          aq: paramAQ,\n          ag: paramAG,\n          value: computeLambdaQ(paramAQ, paramAG),\n        });\n      }\n    }\n  }\n  return lambdaGQData;\n};\n\n\n\n\n\n\n\nplotLambdaGQ = {\n  const plotLambdaGQ = Plot.plot({\n    aspectRatio: 1,\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"λ\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"A  \" },\n    y: {\n      ticks: d3.range(0, 1.01, 0.1),\n      domain: [1.05, -0.05],\n      label: \"A\",\n    },\n    fx: { label: null },\n    className: \"LambdaGQ\",\n    marks: [\n      Plot.frame(),\n      Plot.rect(lambdaGQData, {\n        x1: d =&gt; d.aq - 0.05,\n        x2: d =&gt; d.aq + 0.05,\n        y1: d =&gt; d.ag - 0.05,\n        y2: d =&gt; d.ag + 0.05,\n        fx: \"key\",\n        fill: \"value\",\n      }),\n      Plot.text(lambdaGQData, {\n        x: \"aq\",\n        y: \"ag\",\n        fx: \"key\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotLambdaGQ)\n    .select(\"g[aria-label='x-axis label']\")\n    .select(\"text\")\n    .clone(false)\n      .attr(\"transform\", changeTranslation(-12, 1.5))\n      .attr(\"font-size\", \"0.6em\")\n      .attr(\"font-weight\", \"600\")\n      .text(\"Q\");\n\n  d3.select(plotLambdaGQ)\n    .select(\"g[aria-label='y-axis label']\")\n    .select(\"text\")\n      .attr(\"transform\", changeTranslation(0, 10))\n    .clone(false)\n      .attr(\"transform\", changeTranslation(14, 4.1))\n      .attr(\"font-size\", \"0.6em\")\n      .attr(\"font-weight\", \"600\")\n      .text(\"G\");\n\n  return plotLambdaGQ;\n};\n\n\n\n\n\n\n\n\nFigure 22: Liquidity pool split \\lambda_G, \\lambda_Q.\n\n\n\n\n\n3.3.5 Risk Premium Distribution\nFor \\lambda_{GG}, \\lambda_G, \\lambda_Q we apply \\beta:\n\n\\Lambda_X = \\lambda_X \\, \\beta, \\quad \\text{for } X \\in \\{GG, G, Q\\}\n\\tag{26}\nTaking b as a discount parameter:\n\nb = \\frac{\\sum_1^{40} Z_t \\, S_t \\, B_t}{\\sum_1^{40} Z_t \\, S_t }\n\\tag{27}\nThe total Risk Premium tokens R_\\lambda:\n\nR_\\lambda = b \\, R \\, (\\Lambda_{GG} + \\Lambda_G + \\Lambda_Q)\n\\tag{28}\nThe allocations of R_\\lambda are pro-rata to \\Lambda_{GG}, \\Lambda_G, \\Lambda_Q, and thereafter:\n\nLocked G: \\Lambda_{GG} in proportion to G.\nLocked AG, AQ tokens are allocated a weighting G_t, Q_t depending on their time bucket t:\n\nG_t = \\frac{Z_t \\, L_{Gt} \\, B_t}{\\sum Z_t \\, L_{Gt} \\, B_t}\n  \\tag{29}\n\nQ_t = \\frac{Z_t \\, L_{Qt} \\, B_t}{\\sum Z_t \\, L_{Qt} \\, B_t}\n  \\tag{30}\nWhere L_{Gt}, L_{Qt} are the proportion of all liquidity locked in each time bucket for AG and AQ respectively.\n\nThereafter each time bucket allocation is proportionate to staked liquidity provider token holdings.\n\n\n\n3.4 Interactive Model\nThis additional section is only in the interactive version of the whitepaper. It presents an interactive model of the AAM where each parameter of interest can be adjusted by the reader.\nIn Section 3.4.1, a carbon holder sells carbon to the AAM in exchange for A tokens; from the point of view of the AAM, this represents a carbon purchase. In Section 3.4.2, a holder of A tokens burns them to buy carbon from the AAM; from the point of view of the AAM, this represents a carbon sale.\n\n3.4.1 kVCM Tokens Minted When the AAM Purchases Carbon\nIn this section, the reader controls how many present-value tonnes of carbon class i are purchased by the AAM. The number of A tokens emitted in exchange is calculated in real time. The price of carbon class i is calculated by dividing the number of A tokens emitted by the AAM by the number of present-value tonnes of carbon class i purchased by the AAM.\n\n\n\nfunction piecewiseLogTransform(xTran = 1) {\n  return x =&gt; x &gt; xTran ? Math.log(x) : x - xTran + Math.log(xTran);\n}\n\nfunction piecewiseLogInvert(xTran = 1) {\n  return y =&gt; y &gt; Math.log(xTran) ? Math.exp(y) : y - Math.log10(xTran) + xTran;\n}\n\nfunction setInput(input, value) {\n  input.value = value;\n  input.dispatchEvent(new Event(\"input\", { bubbles: true }));\n}\n\nfunction numDigits(x) {\n  return x === 0 ? 1 : (1 + Math.floor(Math.log10(x)));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndefaultAValue = 2e6;\ndefaultASupply = 2e7;\ndefaultPresentTonnes = 1e7;\ndefaultDeltaTonnes = 1e2;\ndefaultAi = 0.5;\ndefaultGi = 0.5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.button(\n  [[\"Reset\", () =&gt; {\n    setInput(viewof inputAValue, defaultAValue);\n    setInput(viewof inputASupply, defaultASupply);\n    setInput(viewof inputPresentTonnes, defaultPresentTonnes);\n    setInput(viewof inputDeltaTonnes, defaultDeltaTonnes);\n    setInput(viewof inputAi, defaultAi);\n    setInput(viewof inputGi, defaultGi);\n  }]],\n);\n\n\n\n\n\n\n\nviewof inputAValue = Inputs.range([1e5, 1e9], {\n  label: tex`\\text{Market cap. of \\textbf{A}}`,\n  step: 1,\n  value: defaultAValue,\n  transform: Math.log,\n});\nviewof inputASupply = Inputs.range([1e6, 1e10], {\n  label: tex`\\text{Supply of \\textbf{A}}`,\n  step: 1,\n  value: defaultASupply,\n  transform: Math.log,\n});\nviewof inputPresentTonnes = Inputs.range([0, 1e9], {\n  label: tex`\\text{Portfolio } \\bar C_i`,\n  step: 1e-3,\n  value: defaultPresentTonnes,\n  transform: piecewiseLogTransform(1e-3),\n  invert: piecewiseLogInvert(1e-3),\n});\nviewof inputDeltaTonnes = Inputs.range([1e-3, 1e7], {\n  label: tex`\\text{Purchased tonnes}`,\n  step: 1e-3,\n  value: defaultDeltaTonnes,\n  transform: Math.log,\n});\nviewof inputAi = Inputs.range([0, 1], {\n  label: tex`\\text{Allocation } A_i`,\n  step: 1e-6,\n  value: defaultAi,\n  transform: piecewiseLogTransform(1e-6),\n  invert: piecewiseLogInvert(1e-6),\n});\nviewof inputGi = Inputs.range([0, 1], {\n  label: tex`\\text{Allocation } G_i`,\n  step: 1e-6,\n  value: defaultGi,\n});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nparamDeltaA = computeTrueDeltaA(\n  inputAi,\n  inputGi,\n  inputPresentTonnes,\n  inputDeltaTonnes,\n);\nparamDeltaTonnes = paramDeltaA === 0 ? 0 : inputDeltaTonnes;\nparamAEmitted = paramDeltaA * inputASupply;\nparamAPrice = inputAValue / inputASupply;\nparamBarCiPrice = inputAValue * paramDeltaA / inputDeltaTonnes;\n\nstringASupply = inputASupply.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 2 - numDigits(paramAEmitted)),\n    maximumFractionDigits: Math.max(0, 2 - numDigits(paramAEmitted)),\n  },\n) + \" kVCM\";\nstringPresentTonnes = inputPresentTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 3 - numDigits(paramDeltaTonnes)),\n    maximumFractionDigits: Math.max(0, 3 - numDigits(paramDeltaTonnes)),\n  },\n) + \" tCO2eq\";\nstringAEmitted = \"+\" + paramAEmitted.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, numDigits(paramAEmitted)),\n    maximumSignificantDigits: Math.max(2, numDigits(paramAEmitted)),\n  },\n) + \" kVCM\";\nstringDeltaTonnes = \"+\" + paramDeltaTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(3, numDigits(paramDeltaTonnes)),\n    maximumSignificantDigits: Math.max(3, numDigits(paramDeltaTonnes)),\n  },\n) + \" tCO2eq\";\nstringAPrice = \"$\" + paramAPrice.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice)),\n  },\n);\nstringBarCiPrice = \"$\" + paramBarCiPrice.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramBarCiPrice)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramBarCiPrice)),\n  },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSupply of A Tokens\nPortfolio Carbon\n\n\n\n\nTotal\n\n\n\n\nVariation\n\n\n\n\nUnit Price\n\n\n\n\n\n\n\n\n\n\n\n3.4.2 Carbon Sold by the AAM When it Burns kVCM Tokens\nIn this section, the reader controls how many A tokens are burnt by the AAM. The number of liquid tonnes of carbon class i sold by the AAM in exchange is calculated in real time. The price of carbon is calculated by dividing the number of A tokens burnt by the AAM by the number of liquid tonnes of carbon class i sold by the AAM.\n\n\n\ndefaultLiquidTonnes = 1e7;\ndefaultABurnt = 1e2;\ndefaultGnull = 0.5;\ndefaultA = 0.5;\ndefaultS = 0.5;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.button(\n  [[\"Reset\", () =&gt; {\n    setInput(viewof inputAValue_, defaultAValue);\n    setInput(viewof inputASupply_, defaultASupply);\n    setInput(viewof inputLiquidTonnes, defaultLiquidTonnes);\n    setInput(viewof inputABurnt, defaultABurnt);\n    setInput(viewof inputAi, defaultAi);\n    setInput(viewof inputGi, defaultGi);\n  }]],\n);\n\n\n\n\n\n\n\nviewof inputAValue_ = Inputs.range([1e5, 1e9], {\n  label: tex`\\text{Market cap. of \\textbf{A}}`,\n  step: 1,\n  value: defaultAValue,\n  transform: Math.log,\n});\nviewof inputASupply_ = Inputs.range([1e6, 1e10], {\n  label: tex`\\text{Supply of \\textbf{A}}`,\n  step: 1,\n  value: defaultASupply,\n  transform: Math.log,\n});\nviewof inputLiquidTonnes = Inputs.range([1e-3, 1e9], {\n  label: tex`\\text{Portfolio } C_{i0}`,\n  step: 1e-3,\n  value: defaultLiquidTonnes,\n  transform: Math.log,\n});\nviewof inputABurnt = Inputs.range([1e-1, 1e6], {\n  label: tex`\\text{\\textbf{A} tokens burnt}`,\n  step: 1e-1,\n  value: defaultABurnt,\n  transform: Math.log,\n});\nInputs.bind(\n  Inputs.range([0, 1], {\n    label: tex`\\text{Allocation } A_i`,\n    step: 1e-6,\n    value: defaultAi,\n    transform: piecewiseLogTransform(1e-6),\n    invert: piecewiseLogInvert(1e-6),\n  }),\n  viewof inputAi,\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInputs.bind(\n  Inputs.range([0, 1], {\n    label: tex`\\text{Allocation } G_i`,\n    step: 1e-6,\n    value: defaultGi,\n  }),\n  viewof inputGi,\n);\n\n\n\n\n\n\n\n\n\nparamABurnt = inputAi === 0 ? 0 : inputABurnt\nparamDeltaA_ = paramABurnt / inputASupply_;\nparamDeltaCi = inputAi === 0 ? -0 : computeDeltaCi(\n  inputAi,\n  inputGi,\n  paramDeltaA_,\n);\nparamDeltaCiTonnes = -paramDeltaCi * inputLiquidTonnes;\nparamAPrice_ = inputAValue_ / inputASupply_;\nparamCiPrice = inputAi === 0 ? 0 : inputAValue_ * paramDeltaA_ / paramDeltaCiTonnes;\n\nstringASupply_ = inputASupply_.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 2 - numDigits(paramABurnt)),\n    maximumFractionDigits: Math.max(0, 2 - numDigits(paramABurnt)),\n  },\n) + \" kVCM\";\nstringLiquidTonnes = inputLiquidTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumFractionDigits: Math.max(0, 2 - numDigits(paramDeltaCiTonnes)),\n    maximumFractionDigits: Math.max(0, 2 - numDigits(paramDeltaCiTonnes)),\n  },\n) + \" tCO2eq\";\nstringABurnt = \"−\" + paramABurnt.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, numDigits(paramABurnt)),\n    maximumSignificantDigits: Math.max(2, numDigits(paramABurnt)),\n  },\n) + \" kVCM\";\nstringDeltaCiTonnes = \"−\" + paramDeltaCiTonnes.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, numDigits(paramDeltaCiTonnes)),\n    maximumSignificantDigits: Math.max(2, numDigits(paramDeltaCiTonnes)),\n  },\n) + \" tCO2eq\";\nstringAPrice_ = \"$\" + paramAPrice_.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice_)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramAPrice_)),\n  },\n);\nstringCiPrice = \"$\" + paramCiPrice.toLocaleString(\n  \"en-GB\",\n  {\n    minimumSignificantDigits: Math.max(2, 2 + numDigits(paramCiPrice)),\n    maximumSignificantDigits: Math.max(2, 2 + numDigits(paramCiPrice)),\n  },\n);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSupply of A Tokens\nPortfolio Carbon\n\n\n\n\nTotal\n\n\n\n\nVariation\n\n\n\n\nUnit Price"
  },
  {
    "objectID": "index.html#sec-klima-2.0-token-distribution",
    "href": "index.html#sec-klima-2.0-token-distribution",
    "title": "Klima 2.0",
    "section": "4 Klima 2.0 Token Distribution",
    "text": "4 Klima 2.0 Token Distribution\n\n4.1 Planned Allocations\n\n\n\n\n\n\nCohort\nProportion\nQuantity (m)\n\n\n\n\nKlima Holders\n87.5%\n17.5\n\n\nDAO/Treasury\n10.0%\n2.0\n\n\n01X\n2.5%\n0.5\n\n\nTotal\n100.0%\n20.0\n\n\n\n\n\nTable 3: kVCM token.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCohort\nProportion\nQuantity (m)\nLiquidity\n\n\n\n\nKlima Holders\n40.0%\n40.0\nLogistic Vesting 48 months\n\n\nEcosystem Grant\n5.0%\n5.0\nLogistic Vesting 48 months\n\n\nProgrammatic Incentives\n40.0%\n40.0\nIncentive Curve\n\n\npKlima Holders\n3.0%\n3.0\nLogistic Vesting 48 months\n\n\nDAO/Treasury\n4.5%\n4.5\n24 month locked LP of AG\n\n\n01X\n2.5%\n2.5\n24 month locked LP of AG\n\n\nProduct Design and Development\n5.0%\n5.0\nLogistic Vesting 48 months\n\n\nTotal\n100.0%\n100.0\n\n\n\n\n\n\nTable 4: K2 token.\n\n\n\n\n\n\n\nallocInitGData = {\n  const allocInitGData = [];\n  for (let i = 0; i &lt; 100.01; i += 0.25) {\n    if (i &lt; 2.51) {\n      allocInitGData.push({ key: \"01X\", value: i });\n    }\n    if (2.49 &lt; i && i &lt; 5.51) {\n      allocInitGData.push({ key: \"pKlima Holders\", value: i });\n    }\n    if (5.49 &lt; i && i &lt; 10.01) {\n      allocInitGData.push({ key: \"DAO/Treasury\", value: i });\n    }\n    if (9.99 &lt; i && i &lt; 15.01) {\n      allocInitGData.push({ key: \"Ecosystem Grant\", value: i });\n    }\n    if (14.99 &lt; i && i &lt; 20.01) {\n      allocInitGData.push({ key: \"Product Design\", value: i });\n    }\n    if (19.99 &lt; i && i &lt; 60.01) {\n      allocInitGData.push({ key: \"Klima Holders\", value: i });\n    }\n    if (59.99 &lt; i) {\n      allocInitGData.push({ key: \"Incentives\", value: i });\n    }\n  }\n  return allocInitGData;\n};\nlongitudeScale = d3.scaleLinear([180, -180]);\ngetCenter = d =&gt;\n        [1.25, 4, 7.75, 12.5, 17.5, 40, 80].includes(d.value) ? d.value : NaN;\n\ncohortsDomain = [\n  \"Incentives\",\n  \"Klima Holders\",\n  \"Product Design\",\n  \"Ecosystem Grant\",\n  \"DAO/Treasury\",\n  \"pKlima Holders\",\n  \"01X\",\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  projection: { type: \"azimuthal-equidistant\", rotate: [0, -90], scale: 2 },\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  marks: [\n    Plot.area(allocInitGData, {\n      x1: ({ value }) =&gt; longitudeScale(value / 100),\n      y1: -20,\n      x2: ({ value }) =&gt; longitudeScale(value / 100),\n      y2: -70,\n      fill: \"key\",\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\nFigure 23: K2 token allocations.\n\n\n\n\n\n4.2 Programmatic Incentive Curve\nThe incentive issuance is built on a logistic function, \\operatorname{P}, to generate total proportion of supply in issue. It is calibrated from the initial issuance at TGE P_0 and the inflection point time T where 50% of G token incentives have been released.\nSetting x_0 from the initial supply parameter:\n\nx_0 = \\ln\\left( \\frac{P_0}{1 - P_0} \\right)\n\\tag{31}\nWith x_t at time point t \\in (0, \\infty):\n\nx_t = x_0 \\, \\left( 1 - \\frac t T \\right)\n\\tag{32}\nGiving supply function \\operatorname{P}(t) as:\n\n\\operatorname{P}(t) = \\frac{\\exp(x_t)}{\\exp(x_t) + 1}\n\\tag{33}\nP_0 set at  and T at  months:\n\n\n\nviewof inputP0 = Inputs.range([0.01, 0.5], {\n  label: tex`\\text{Initial issuance } P_0`,\n  step: 0.01,\n  value: 0.07,\n});\nviewof inputT = Inputs.range([2, 60], {\n  label: tex`T \\text{ (months)}`,\n  step: 1,\n  value: 24,\n});\n\nstringInputP0 = inputP0.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n);\nstringInputT = inputT.toLocaleString(\"en-GB\", { maximumFractionDigits: 0 });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeP(t, P0, T) {\n  const x0 = Math.log(P0 / (1 - P0));\n  const xt = x0 * (1 - t / T);\n  const exp = Math.exp(xt);\n  return exp / (exp + 1);\n}\n\nfunction computeDerivP(t, P0, T) {\n  const x0 = Math.log(P0 / (1 - P0));\n  const xt = x0 * (1 - t / T);\n  const exp = Math.exp(xt);\n  const P = exp / (1 + exp);\n  return -(x0 / T) * P * (1 - P);\n}\n\nfunction getVesting(vecVesting, t, tStart, tEnd) {\n  if (t &lt; tStart)\n    return 0;\n  else if (t &lt; tEnd) {\n    return vecVesting[t - tStart];\n  } else {\n    return vecVesting[tEnd - tStart - 1];\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntVestStart = 3;\ntVestEnd = 2 * inputT;\ntVesting = d3.range(tVestStart, tVestEnd);\nvecVestingDeriv = normalize(tVesting.map(t =&gt;\n  computeDerivP(t, inputP0, inputT)\n));\nvecVesting = d3.cumsum(vecVestingDeriv);\n\nsupplyDataAll = {\n  let paramVestingPrevious = 0;\n  const vecSupplyIncentives = [];\n  const vecSupplyCirculating = [];\n  const supplyData = [];\n  for (let t = 0; t &lt;= 72; t++) {\n    const paramP = computeP(t, inputP0, inputT);\n    const paramDerivP = computeDerivP(t, inputP0, inputT);\n    const paramVesting = getVesting(vecVesting, t, tVestStart, tVestEnd);\n    const paramVestingDiff = paramVesting - paramVestingPrevious;\n    paramVestingPrevious = paramVesting;\n\n    const supply01X = 2.5;\n    const supplyPKlima = 3 * paramVesting;\n    const supplyTreasury = 4.5;\n    const supplyGrant = 5 * paramVesting;\n    const supplyProduct = 5 * paramVesting;\n    const supplyKlima = 40 * paramVesting;\n    const supplyIncentives = 40 * paramP;\n    vecSupplyIncentives.push(supplyIncentives);\n\n    const supply01XStacked = supply01X;\n    const supplyPKlimaStacked = supplyPKlima + supply01XStacked;\n    const supplyTreasuryStacked = supplyTreasury + supplyPKlimaStacked;\n    const supplyGrantStacked = supplyGrant + supplyTreasuryStacked;\n    const supplyProductStacked = supplyProduct + supplyGrantStacked;\n    const supplyKlimaStacked = supplyKlima + supplyProductStacked;\n    const supplyIncentivesStacked = supplyIncentives + supplyKlimaStacked;\n    const supplyCirculating = supplyIncentivesStacked / 100;\n    vecSupplyCirculating.push(supplyIncentivesStacked);\n\n    if (t &lt;= 60) {\n      const diffIncentives = 40 * (t === 0 ? inputP0 : paramDerivP);\n      const diffKlima = 40 * paramVestingDiff;\n      const diffProduct = 5 * paramVestingDiff;\n      const diffGrant = 5 * paramVestingDiff;\n      const diffPKlima = 3 * paramVestingDiff;\n      const diffTreasury = t === 0 ? 4.5: 0;\n      const diff01X = t === 0 ? 2.5 : 0;\n\n      const diffIncentivesStacked = diffIncentives;\n      const diffKlimaStacked = diffKlima + diffIncentivesStacked;\n      const diffProductStacked = diffProduct + diffKlimaStacked;\n      const diffGrantStacked = diffGrant + diffProductStacked;\n      const diffPKlimaStacked = diffPKlima + diffGrantStacked;\n      const diffTreasuryStacked = diffTreasury + diffPKlimaStacked;\n      const diff01XStacked = diff01X + diffTreasuryStacked;\n\n      supplyData.push({\n        key: \"Proportion of Supply\",\n        x: t,\n        y: 100 * paramP,\n      });\n      supplyData.push({\n        key: \"Rate of Change\",\n        x: t,\n        y: 100 * paramDerivP,\n      });\n\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01XStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlimaStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasuryStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrantStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProductStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlimaStacked / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Stacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentivesStacked / supplyCirculating,\n      });\n\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01X / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlima / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasury / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrant / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProduct / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlima / supplyCirculating,\n      });\n      supplyData.push({\n        key: \"Circulating Supply (Unstacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentives / supplyCirculating,\n      });\n\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01XStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlimaStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasuryStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrantStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProductStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlimaStacked,\n      });\n      supplyData.push({\n        key: \"Total Supply (Stacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentivesStacked,\n      });\n\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: supply01X,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: supplyPKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: supplyTreasury,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: supplyGrant,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: supplyProduct,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: supplyKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply (Unstacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: supplyIncentives,\n      });\n\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Incentives\",\n        x: t,\n        y: diffIncentives,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Klima Holders\",\n        x: t,\n        y: diffKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Product Design\",\n        x: t,\n        y: diffProduct,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"Ecosystem Grant\",\n        x: t,\n        y: diffGrant,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"pKlima Holders\",\n        x: t,\n        y: diffPKlima,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"DAO/Treasury\",\n        x: t,\n        y: diffTreasury,\n      });\n      supplyData.push({\n        key: \"Total Supply Differential (Unstacked)\",\n        cohort: \"01X\",\n        x: t,\n        y: diff01X,\n      });\n    }\n  }\n\n  const vecNextYearIncentives = vecSupplyIncentives.map((val, t) =&gt;\n    vecSupplyIncentives[t + 12] - val);\n  const vecAPY = vecSupplyCirculating.map((val, t) =&gt;\n    100 * (vecSupplyCirculating[t + 12] - val) / val);\n  const vecAPR = vecSupplyCirculating.map((val, t) =&gt;\n    100 * (vecSupplyCirculating[t + 12] - vecNextYearIncentives[t] - val) / val);\n\n  for (let t = 0; t &lt;= 60; t++) {\n    supplyData.push({ key: \"APY\", x: t, y: vecAPY[t] });\n    supplyData.push({ key: \"APR\", x: t, y: vecAPR[t] });\n  }\n  return [\n    vecSupplyIncentives,\n    vecSupplyCirculating,\n    supplyData,\n    vecAPY,\n    vecAPR,\n  ];\n}\nvecSupplyIncentives = supplyDataAll[0];\nvecSupplyCirculating = supplyDataAll[1];\nsupplyData = supplyDataAll[2];\nvecAPY = supplyDataAll[3];\nvecAPR = supplyDataAll[4];\n\ngetLogisticCurve = d =&gt; d.key === \"Proportion of Supply\" ? d.y : NaN;\ngetRateOfChange = d =&gt; d.key === \"Rate of Change\" ? d.y : NaN;\ngetCirculatingStacked = d =&gt;\n        d.key === \"Circulating Supply (Stacked)\" ? d.y : NaN;\ngetCirculatingUnstacked = d =&gt;\n        d.key === \"Circulating Supply (Unstacked)\" ? d.y : NaN;\ngetTotalStacked = d =&gt; d.key === \"Total Supply (Stacked)\" ? d.y : NaN;\ngetTotalUnstacked = d =&gt; d.key === \"Total Supply (Unstacked)\" ? d.y : NaN;\ngetDiffUnstacked = d =&gt;\n        d.key === \"Total Supply Differential (Unstacked)\" ? d.y : NaN;\ngetCohortCirculatingStacked = d =&gt;\n        d.key === \"Circulating Supply (Stacked)\" ? d.cohort : NaN;\ngetCohortCirculatingUnstacked = d =&gt;\n        d.key === \"Circulating Supply (Unstacked)\" ? d.cohort : NaN;\ngetCohortTotalStacked = d =&gt;\n        d.key === \"Total Supply (Stacked)\" ? d.cohort : NaN;\ngetCohortTotalUnstacked = d =&gt;\n        d.key === \"Total Supply (Unstacked)\" ? d.cohort : NaN;\ngetCohortDiffUnstacked = d =&gt;\n        d.key === \"Total Supply Differential (Unstacked)\" ? d.cohort : NaN;\ngetAPY = d =&gt; d.key === \"APY\" ? d.y : NaN;\ngetAPR = d =&gt; d.key === \"APR\" ? d.y : NaN;\n\ndomainRateOfChange = [0, d3.max(supplyData, getRateOfChange)];\nscaleRateOfChange = d3.scaleLinear(domainRateOfChange, [0, 100]);\nmapScaleRateOfChange = x =&gt; x.map(scaleRateOfChange);\n\nstringP0 = \"Initial Issuance P₀ = \" + inputP0.toLocaleString(\n  \"en-GB\",\n  { style: \"percent\", maximumFractionDigits: 0 },\n);\nstringT = \"Inflection Point Time T = \" + inputT.toLocaleString(\n  \"en-GB\",\n  { maximumFractionDigits: 0 },\n) + \" months\";\n\nsupplyParams = [\n  { key: stringP0, x: 0.5, y: 100 * inputP0 },\n  { key: stringT, x: inputT, y: 50 },\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [5, 7, 0, 2].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"Proportion of Supply\", \"Rate of Change\", stringP0, stringT],\n  },\n  x: {\n    ticks: d3.range(0, 60.1, 12),\n    label: \"‘Life’ Span (Months)\",\n    grid: true,\n  },\n  y: { domain: [0, 100] },\n  insetTop: 16,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.axisY({ anchor: \"left\", label: \"Proportion of Supply (%)\" }),\n    Plot.axisY(scaleRateOfChange.ticks(), {\n      anchor: \"right\",\n      tickFormat: scaleRateOfChange.tickFormat(),\n      label: \"Rate of Change (%/Month)\",\n      y: scaleRateOfChange\n    }),\n    Plot.lineY(supplyData, Plot.mapY(mapScaleRateOfChange, {\n      x: \"x\",\n      y: getRateOfChange,\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    })),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getLogisticCurve,\n      stroke: \"key\",\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, Plot.mapY(mapScaleRateOfChange, {\n      x: \"x\",\n      y: getRateOfChange,\n      fill: \"key\",\n      fillOpacity: 0.3,\n    })),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y: getLogisticCurve,\n      fill: \"key\",\n      fillOpacity: 0.3,\n    }),\n    Plot.ruleX(supplyParams, {\n      x: d =&gt; d.key === stringT ? d.x : NaN,\n      y: \"y\",\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n    Plot.dotY(supplyParams, {\n      x: \"x\",\n      y: \"y\",\n      r: 5,\n      fill: \"key\",\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\nFigure 24: Incentive Issuance\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { domain: [0, 100], label: \"Circulating Supply (%)\", grid: true },\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getCirculatingStacked,\n      stroke: getCohortCirculatingStacked,\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y: getCirculatingUnstacked,\n      fill: getCohortCirculatingUnstacked,\n      fillOpacity: 0.5,\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\nFigure 25: K2 token circulating supply over time.\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { domain: [0, 100], label: \"Total Supply (%)\", grid: true },\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getTotalStacked,\n      stroke: getCohortTotalStacked,\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y: getTotalUnstacked,\n      fill: getCohortTotalUnstacked,\n      fillOpacity: 0.5,\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n(a) Total supply (stacked).\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { label: \"Total Supply (%)\", grid: true },\n  insetTop: 16,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getTotalUnstacked,\n      stroke: getCohortTotalUnstacked,\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y1: 0,\n      y2: getTotalUnstacked,\n      fill: getCohortTotalUnstacked,\n      fillOpacity: 0.2,\n    }),\n  ]\n})\n\n\n\n\n\n\n\n\n(b) Total supply (unstacked).\n\n\n\n\n\n\nFigure 26: K2 token total supply over time.\n\n\n\n\n\n\n\nPlot.plot({\n  color: { legend: true, range: d3.schemeCategory10, domain: cohortsDomain },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: { label: \"Rate of Growth (%/Month)\", grid: true },\n  insetTop: 16,\n  insetLeft: 8,\n  insetRight: 8,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.rectY(supplyData, {\n      x1: d =&gt; d.x - 0.45,\n      x2: d =&gt; d.x + 0.45,\n      y: getDiffUnstacked,\n      fill: getCohortDiffUnstacked,\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\n(a) Total supply differential (stacked).\n\n\n\n\n\nPlot.plot({\n  color: {\n    legend: true,\n    range: [9, 8].map(i =&gt; d3.schemeCategory10[i]),\n    domain: [\"APY\", \"APR\"],\n  },\n  x: { ticks: d3.range(0, 60.1, 12), label: \"Time (Months)\", grid: true },\n  y: {\n    domain: [0, Math.max(d3.max(vecAPR), d3.max(vecAPY))],\n    label: \"Annual Percentage (%)\",\n    grid: true,\n  },\n  insetTop: 16,\n  clip: true,\n  marks: [\n    Plot.frame(),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getAPY,\n      stroke: \"key\",\n      strokeWidth : 2,\n    }),\n    Plot.areaY(supplyData, {\n      x: \"x\",\n      y1: 0,\n      y2: getAPY,\n      fill: \"key\",\n      fillOpacity: 0.2,\n    }),\n    Plot.lineY(supplyData, {\n      x: \"x\",\n      y: getAPR,\n      stroke: \"key\",\n      strokeWidth : 2,\n      strokeDasharray: 4,\n    }),\n  ]\n});\n\n\n\n\n\n\n\n\n(b) Utility incentive yield.\n\n\n\n\n\n\nFigure 27: K2 token supply risk metrics.\n\n\n\n\n\n\n\n\n\n4.3 Incentive Allocations\n\n\n\n\n\n\nFigure 28: K2 token incentive distribution structure.\n\n\n\nThe relative utilisation measurement factor \\upsilon is calculated as follows.\nDefining initially:\n\nG: Total G tokens staked expressed as a proportion of the circulating supply, G \\in [0, 1].\nL: Total G tokens held in the AG pool expressed as a proportion of circulating supply, L \\in (0, 1].\n\nWhere \\upsilon = 0 if G + L = 0, otherwise:\n\n\\upsilon = \\left( \\frac{2 G L}{G^2 + L^2} \\right)^2\n\\tag{34}\n\n\n\n\nfunction computeUpsilon(G, L) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return (2 * G * L / (G**2 + L**2))**2;\n  }\n}\n\n\n\n\n\n\n\nupsilonData = {\n  const upsilonData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.05) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.05) {\n      if (paramG + paramL &lt; 1.01) {\n        upsilonData.push({\n          key: \"υ\",\n          l: paramL,\n          g: paramG,\n          value: computeUpsilon(paramG, paramL),\n        });\n      }\n    }\n  }\n  return upsilonData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  aspectRatio: 1,\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: \"Relative Utilisation υ\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n  y: {\n    ticks: d3.range(0, 1.01, 0.1),\n    domain: [1.025, -0.025],\n    label: \"Stake G\",\n  },\n  marks: [\n    Plot.frame(),\n    Plot.rect(upsilonData, {\n      x1: d =&gt; d.l - 0.025,\n      x2: d =&gt; d.l + 0.025,\n      y1: d =&gt; d.g - 0.025,\n      y2: d =&gt; d.g + 0.025,\n      fill: \"value\",\n    }),\n    Plot.text(upsilonData, {\n      x: \"l\",\n      y: \"g\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 29: Upsilon \\upsilon range of values.\n\n\n\nThe absolute utilisation parameter \\eta is defined as \\eta = 0 if G + L = 0, otherwise:\n\n\\eta = \\frac{2 G L}{G (1 - G) + L ( 1 - L)}\n\\tag{35}\n\n\n\n\nfunction computeEta(G, L) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return 2 * G * L / (G * (1 - G) + L * (1 - L));\n  }\n}\n\n\n\n\n\n\n\netaData = {\n  const etaData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.05) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.05) {\n      if (paramG + paramL &lt; 1.01) {\n        etaData.push({\n          key: \"η\",\n          l: paramL,\n          g: paramG,\n          value: computeEta(paramG, paramL),\n        });\n      }\n    }\n  }\n  return etaData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  aspectRatio: 1,\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: \"Absolute Utilisation η\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n  y: {\n    ticks: d3.range(0, 1.01, 0.1),\n    domain: [1.025, -0.025],\n    label: \"Stake G\",\n  },\n  marks: [\n    Plot.frame(),\n    Plot.rect(etaData, {\n      x1: d =&gt; d.l - 0.025,\n      x2: d =&gt; d.l + 0.025,\n      y1: d =&gt; d.g - 0.025,\n      y2: d =&gt; d.g + 0.025,\n      fill: \"value\",\n    }),\n    Plot.text(etaData, {\n      x: \"l\",\n      y: \"g\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n      ),\n    }),\n  ],\n});\n\n\n\n\n\n\n\n\nFigure 30: Eta \\eta range of values.\n\n\n\nIncentives I are allocated as follows:\n\n4.3.1 Treasury\nThe allocation to the Treasury I_T is the imbalance generated from \\upsilon:\n\nI_T = 1 - \\upsilon \\, \\eta\n\\tag{36}\n\n\n4.3.2 Post Treasury\nThe residual post-treasury allocation is shared four ways within 2 buckets:\n\nTime-locked A & user-locked G tokens\nWhere S is the proportion of time-locked A tokens (as defined previously in Section 3.1):\n\nTime-locked A, I_S:\n\nI_S = S \\, \\frac{L^2}{G^2 + L^2}\n  \\tag{37}\nUser-locked G, I_G:\n\nI_G = (1 - S) \\, \\frac{L^2}{G^2 + L^2}\n  \\tag{38}\n\nLiquidity\nWith \\lambda_G, \\lambda_Q, \\lambda_{GG} as defined in Section 3.3.4:\n\nAG pool I_{AG}:\n\nI_{AG} = \\frac{\\lambda_G}{1 - \\lambda_{GG}} \\, \\frac{G^2}{G^2 + L^2}\n  \\tag{39}\nAQ pool I_{AQ}:\n\nI_{AQ} = \\frac{\\lambda_Q}{1 - \\lambda_{GG}} \\, \\frac{G^2}{G^2 + L^2}\n  \\tag{40}\n\n\n\n\n\nviewof inputS_ = Inputs.range([0, 1], {\n  label: tex`\\text{Time-Locked } S`,\n  step: 0.01,\n  value: 0.5,\n});\n\nviewof inputWeightAG = Inputs.range([0, 1], {\n  label: tex`\\text{LP split}`,\n  step: 0.01,\n  value: 0.5,\n});\n\nparamWeightAQ = 1 - inputWeightAG;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeTreasury(G, L) {\n  return Math.max(0, 1 - computeUpsilon(G, L) * computeEta(G, L));\n}\n\n\n\n\n\n\n\nfunction computeIBonds(G, L, S) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return S * L**2 / (G**2 + L**2);\n  }\n}\n\nfunction computeIStaking(G, L, S) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return (1 - S) * L**2 / (G**2 + L**2);\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction computeIPool(G, L, weight) {\n  if (G === 0 && L === 0) {\n    return 0;\n  } else {\n    return weight * G**2 / (G**2 + L**2);\n  }\n}\n\n\n\n\n\n\n\nallocationSQData = {\n  const allocationSQData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.1) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.1) {\n      if (paramG + paramL &lt; 1.01) {\n        allocationSQData.push({\n          key: \"𝗔 Time-locks Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIBonds(paramG, paramL, inputS_),\n        });\n        allocationSQData.push({\n          key: \"𝗚 User-locks Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIStaking(paramG, paramL, inputS_),\n        });\n      }\n    }\n  }\n  return allocationSQData;\n};\n\n\n\n\n\n\n\nplotAllocationSQ = {\n  const plotAllocationSQ = Plot.plot({\n    aspectRatio: 1,\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"Allocation I\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n    y: {\n      ticks: d3.range(0, 1.01, 0.1),\n      domain: [1.05, -0.05],\n      label: \"Stake G\",\n    },\n    fx: { label: null },\n    marks: [\n      Plot.frame(),\n      Plot.rect(allocationSQData, {\n        x1: d =&gt; d.l - 0.05,\n        x2: d =&gt; d.l + 0.05,\n        y1: d =&gt; d.g - 0.05,\n        y2: d =&gt; d.g + 0.05,\n        fx: \"key\",\n        fill: \"value\",\n      }),\n      Plot.text(allocationSQData, {\n        x: \"l\",\n        y: \"g\",\n        fx: \"key\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotAllocationSQ)\n    .select(\"g[aria-label='y-axis label']\")\n    .select(\"text\")\n      .attr(\"transform\", changeTranslation(0, 10));\n\n  return plotAllocationSQ;\n};\n\n\n\n\n\n\n\n\n(a) Time-locked A and user-locked G allocations.\n\n\n\n\n\nallocationPoolData = {\n  const allocationPoolData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.1) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.1) {\n      if (paramG + paramL &lt; 1.01) {\n        allocationPoolData.push({\n          key: \"𝗔𝗚 Pool Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIPool(paramG, paramL, inputWeightAG),\n        });\n        allocationPoolData.push({\n          key: \"𝗔𝗤 Pool Allocation\",\n          l: paramL,\n          g: paramG,\n          value: computeIPool(paramG, paramL, paramWeightAQ),\n        });\n      }\n    }\n  }\n  return allocationPoolData;\n};\n\n\n\n\n\n\n\nplotAllocationPool = {\n  const plotAllocationPool = Plot.plot({\n    aspectRatio: 1,\n    color: {\n      legend: true,\n      scheme: \"Spectral\",\n      domain: [0, 1],\n      type: \"sequential\",\n      label: \"Allocation I\",\n    },\n    x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n    y: {\n      ticks: d3.range(0, 1.01, 0.1),\n      domain: [1.05, -0.05],\n      label: \"Stake G\",\n    },\n    fx: { label: null },\n    marks: [\n      Plot.frame(),\n      Plot.rect(allocationPoolData, {\n        x1: d =&gt; d.l - 0.05,\n        x2: d =&gt; d.l + 0.05,\n        y1: d =&gt; d.g - 0.05,\n        y2: d =&gt; d.g + 0.05,\n        fx: \"key\",\n        fill: \"value\",\n      }),\n      Plot.text(allocationPoolData, {\n        x: \"l\",\n        y: \"g\",\n        fx: \"key\",\n        text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n          \"en-GB\",\n          { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n        ),\n        fill: d =&gt; contrastingTextColor(\n          d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n        ),\n      }),\n    ],\n  });\n\n  d3.select(plotAllocationPool)\n    .select(\"g[aria-label='y-axis label']\")\n    .select(\"text\")\n      .attr(\"transform\", changeTranslation(0, 10));\n\n  return plotAllocationPool;\n};\n\n\n\n\n\n\n\n\n(b) Liquidity pools allocations.\n\n\n\n\n\n\nFigure 31: Share of non-treasury incentives I_S, I_G, I_{AG} and I_{AQ}.\n\n\n\n\n\n\n\n\n\n\n\ntreasuryData = {\n  const treasuryData = [];\n  for (let paramG = 0; paramG &lt; 1.01; paramG += 0.05) {\n    for (let paramL = 0; paramL &lt; 1.01; paramL += 0.05) {\n      if (paramG + paramL &lt; 1.01) {\n        treasuryData.push({\n          key: \"I_T\",\n          l: paramL,\n          g: paramG,\n          value: computeTreasury(paramG, paramL),\n        });\n      }\n    }\n  }\n  return treasuryData;\n};\n\n\n\n\n\n\n\nPlot.plot({\n  aspectRatio: 1,\n  color: {\n    legend: true,\n    scheme: \"Spectral\",\n    domain: [0, 1],\n    type: \"sequential\",\n    label: \"Allocation I\",\n  },\n  x: { ticks: d3.range(0, 1.01, 0.1), label: \"Liquidity L\" },\n  y: {\n    ticks: d3.range(0, 1.01, 0.1),\n    domain: [1.025, -0.025],\n    label: \"Stake G\",\n  },\n  marks: [\n    Plot.frame(),\n    Plot.rect(treasuryData, {\n      x1: d =&gt; d.l - 0.025,\n      x2: d =&gt; d.l + 0.025,\n      y1: d =&gt; d.g - 0.025,\n      y2: d =&gt; d.g + 0.025,\n      fill: \"value\",\n    }),\n    Plot.text(treasuryData, {\n      x: \"l\",\n      y: \"g\",\n      text: d =&gt; Number.isNaN(d.value) ? \"\" : d.value.toLocaleString(\n        \"en-GB\",\n        { minimumFractionDigits: 2, maximumFractionDigits: 2 },\n      ),\n      fill: d =&gt; contrastingTextColor(\n        d3.scaleSequential([0, 1], d3.interpolateSpectral)(d.value),\n      ),\n    }),\n  ],\n})\n\n\n\n\n\n\n\n\nFigure 32: Treasury incentives I_T."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Klima 2.0",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote the development of liquidity pool pricing functionality may be applicable.↩︎"
  }
]